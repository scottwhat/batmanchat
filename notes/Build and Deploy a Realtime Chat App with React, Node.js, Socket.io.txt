00:00 In this video, we are going to build a fully functional chat application that
00:05 has authentication, real-time messages, online indicators, notification sounds,
00:11 and image uploads. We are going to build our own authentication system and socket
00:17 server from scratch, which means we are not going to use any third-party services in this project. So that you
00:24 can see the entire process of building all these features by yourself. One of
00:29 my favorite features in this application is sending emails. So, as soon as a user
00:35 signs up, we will trigger a function in the background that will hit their inbox
00:40 with a beautiful welcome email. In my opinion, this is one of the best projects that you can build as a
00:47 beginner to level up your skills and have a better understanding of full
00:52 stack web development because you are going to learn how to build a REST API with Node.js JS and Express. You will
00:60 learn how to set up your own scikit server with scikit.io, which is going to
01:05 allow you to have realtime features in your applications. You will learn how to
01:10 create your own authentication system with JSON web tokens, how to send
01:16 emails, setting up a database, image uploads, implementing online and offline
01:21 users, building a beautiful front-end design, and you will even learn how to
01:26 rate limit your API, which is something that most beginners don't really know. But hopefully in this video, you will
01:33 learn how easy it is to integrate. In the front end, we will add a typing effect. So whenever you press a key,
01:40 it'll make a satisfying keyboard sound. So here's an example.
01:55 So this sound is not coming from my keyboard. It is coming from the chat application itself. And if you want to
02:02 turn it off, you can do so by clicking to this button. In this course, you will also learn about Git and GitHub because
02:10 at the end of each section, we will create a new branch, commit our changes,
02:15 create a pull request, and eventually we will merge that request. When it comes
02:20 to the text stack in the back end, we will use Node.js JS and Express to build
02:26 our API. Psych.io for real-time features. MongoDB as our database.
02:32 Resend to send emails. Arcjet to implement rate limiting. JSON web tokens
02:38 for authentication and cloudary for image uploads. In the front end, we will
02:43 use React as our library, Alwin CSS and the UI for styling and Zastand for state
02:51 management. And as always, we are going to deploy this application so that you can put that live link on your resume
02:58 and even share it with your friends. So overall, I think you are going to love this project. And the best part is you
03:05 don't need to pay anything to be able to follow along with me because every tool that we use is completely free to get
03:12 started with and no credit card required at all. So if you're ready, let's jump
03:18 into it. The source code of this project will be free in the description. Give it a star and feel free to use it however
03:25 you wish. One last quick announcement. I have a premium Udemy course with more than 120 hours. We are building all
03:33 kinds of projects from React to Nex.js to Python and Go. If you're interested,
03:38 there are over 5,000 students and everyone enjoys it so far. You can find the discount link in the description.
03:45 Thanks for watching and let's get started. All right. So to get started with I have
03:50 an empty folder on my desktop called Chatify. This is the name that I came up with. You can call this anything that
03:56 you wish. Just go ahead and open this up in VS Code. Just before we get start coding, I'd like to mention that you
04:03 have to have NodeJS installed on your machine. Probably you already have it, but just in case if someone doesn't,
04:10 just go ahead get the long-term support from this drop down. Okay. And for the
04:16 you know editor I'll be using VS Code as you can already tell. Now let's go ahead
04:21 create two different folders. One is for our back end for our API and the other
04:27 one is for the React application under the front end. Now initially we are
04:33 going to build the back end once we are done with it and then we are going to jump into the front end. But while we
04:39 are here I'll just try to initialize a React application. I'll open up my terminal with command J or control J. So
04:48 here I'll just say cd into the front end. I'll say mpm create vit add latest
04:56 and I will say initialize it under the current folder which is front end. So I'll put dot at the end. Okay, we'll go
05:03 with react and javascript. We got all the files and folders. We can run mpm
05:09 install. This is going to get us the node
05:14 modules. And in the first one hour, I'll be going pretty slowly just to make sure
05:19 that we understand everything and I explain everything. Right? Once we understand the basics, then we can speed
05:26 up the process. I'll clear up the terminal. I'll say mpm run death.
05:33 And here we can see that it's going to start from 5173
05:38 as the port. Okay. So we have a basic react application which is working fine.
05:44 Now we can kill this. Open up a new terminal and then just start um a
05:50 backend like NodeJS application under the backend folder. I'll say cydia under the back end. I'll say mpm init-y
05:58 which is going to give us a package json file. Now we'll clear this up and we're going to install a couple of different
06:04 packages. So I'll just kill the left hand side with commandB or controlB. Now
06:10 let's say mpm install express which is going to be our web framework that will
06:15 allow us to build APIs pretty quickly and easily. Now the latest version is
06:20 version 5 but in this tutorial we'll be using version 4. Now this is not old not
06:25 at all like it is completely valid version and most of the code bases are
06:30 still using version 4. So don't feel like this is deprecated or obsolete. Absolutely not. So we'll get this
06:37 version let's say 4.21.2 and then we are going to use mongus so
06:43 that we can communicate with our database which is going to be MongoDB. And again, I'll give you a specific
06:49 version so that if you're watching this video in the future, it should still work out as expected. Okay, so this is
06:55 the version and let's say JSON web token. Let's say JSON web token. This is
07:02 the package that we are going to be using for the authentication. And then you know just make sure that you put the
07:09 exact same version as I do. Then we'll get the bryptjs
07:14 and the version is going to be 2.4.3. I can just zoom out so that you can see
07:20 it clearly. Okay, let's run this.
07:26 Okay, so I just zoomed in. Everything has been installed clearly, right? Without any errors. I'll just clear this
07:33 up and I'll say mpm install couple of other packages as well. let's sayv
07:39 with this specific version 4.7. This package will allow us to access our
07:45 environment variables from av file. And then let's get the cookie dash parser.
07:51 As the name suggests, this is going to allow us to parse the cookies from the
07:56 request. Right? So say 1.4.7. Let's install all these packages and
08:03 just get into the backend folder. try to build a basic API. So first I will
08:08 create a server.js file. Now some people call it as app.js, index.js or server.js
08:17 even main.js but in this case I'll be using this name. This is what I prefer
08:22 in this project. Okay. Now let's try to build a basic API. I'll say express.
08:28 Let's try to require it from the express package. And we can get an app instance
08:34 from Express. I'll just say app.listen just put a port. This is what I'll be
08:40 calling with 3000. And let's say once we start listening, I'll just say server is
08:46 running on this port. Now, how do we run this file? Well, we can create a script
08:52 under the package JSON. I will say delete the test. This is for development. We will say we want to run
08:59 the server.js js file with the node command. Right? So now under the back
09:04 end you can just say something like mpm rundev. But please notice if this was
09:09 something like hello then you would say mpm run hello. Right? Okay. I hope that makes sense. I'll say mpm rundev and we
09:18 can see server is running on this port. Now the problem here is that if you add some changes like 1 2 3 and if you save
09:26 you're not going to see the updated version. you have to kill the terminal with Ctrl C and rerun this again so that
09:33 you can see the latest changes which is not really optimal right we're going to be saving this file a lot every single
09:40 time we don't want to kill this and restart it so to be able to make that work we will just say node d-watch
09:50 so this will basically listen for any change under the back end right under the server js file now let's run this I
09:58 will delete this one, two, three, save. And it's going to restart our server
10:03 with the latest changes. If this did not work, you can install another package.
10:09 So, for some reason, I've seen some comments that says like the watch flag
10:14 did not work. So, you can say npm install notemon
10:20 d. And just before we run this, make sure you save this file. Yep. Run this. Now this is going to get the nodeman
10:27 under the dev dependencies. So you can delete this part and just say nodemon instead of node
10:34 and you can say npm rundev it should be working out with the listening right
10:40 with the listening the changes okay and in this case actually I'll be using node
10:46 one because why not now let's try to use something different so instead of using
10:52 this syntax right instead of using this one I'd like to use import export syntax
10:57 so say import express from express to be able to make that work. Now this is
11:02 currently working but it says you should put the type as module in this file
11:08 otherwise the performance is not going to be uh is not going to be good right
11:14 so you would like to say type is going to be module by default it is common js once you make module this is going to
11:20 work without any warnings right now we don't really have these warnings
11:26 initially it said like you should put the type okay so now we can get rid of this
11:32 commonjs syntax and let's put couple of different endpoints. Let's say app.get
11:39 something like slash API slash oath let's say slash signup. If
11:48 user hits this endpoint we're going to say something like resend signup
11:55 endpoint. Right in here let's duplicate it. We're going to have one for login
12:04 and one for the log out. Let me select this. I'll say log out. Okay. Now, just
12:12 make sure that you're running the API, the server. We can test this out. Localhost 3000 / API o login. This is
12:22 the login endpoint, right? let's say log out and sign up. So we are getting the
12:31 related responses. Now under the back end folder I would like to follow a best
12:36 practice. So if you take a look at our front end, our react application, everything that is related to
12:42 application code is going under the source folder. And this is what I'd like to do. I will create a source folder and
12:49 drag and drop it the server.js into this source folder. Now if you take a look at
12:55 the terminal is going to crash. Let's kill this with Ctrl C. And the solution is basically updating this script. So we
13:03 are saying run the server.js file but path is not correct. It is under the
13:08 source. So we'll say just go under the source and then run this file. Now if
13:13 you run this it should work out correctly, right? And for the production
13:18 we are going to have the exact same script. This time it'll be start and instead of running it with node one, we
13:25 will just run it with node because in production when we deploy it, we don't really need to listen for the changes
13:32 because code is not going to change if you deploy it, right? It is only changing when we are developing this
13:38 application. So that's why we are running it with nodeman. And later in the video, we'll have couple of
13:44 different folders like controllers, let's say routes,
13:50 and everything is going to be under the source folder, right? So, just keep that in mind. Now, let's do one more thing.
13:56 Here we have the port as hardcoded. So, this is not what you really do. Instead,
14:02 you would create av file, not under the source, but under the root, okay, under
14:07 the back end. So, you would create a port environment variable. I'll put 3,00. And later in the video, we'll have
14:14 something like uri, which is our database connection string. I'll say my
14:21 db connection string, which is something not correct. We are going to update it
14:26 later in the video, but this is just to show you an example. So, we would put our configuration variables as well as
14:35 the secrets, right? We don't really want to share this with anyone else. So that's why we are not going to put it in
14:41 our code, but we'll put it under the env file. Now, how do we get this value from
14:47 the env file? Well, we'll first just say like this is how we can get it.
14:53 Process.env.port. Let's console log this.
14:58 Let's say oops, maybe console log process.v.port.
15:06 If you save, you're going to see undefined in the terminal. But you might be asking, we have this. Why are we
15:13 getting undefined? It is because you have to use the env package. So say
15:19 importv from enenv and call this method. Now you can get that value from the env
15:25 file. Let's update it. Say 5,000. Save that file also server.js. As you can
15:31 tell, it is coming from this file. Okay. So just keep that in mind. You
15:38 have to use this package. So we got the port instead of console logging it. I'll
15:43 just say post con port and it is equal to this value. Just in case if this is
15:50 undefined, you can put 30,00 value. Now let's put the port here. And
15:57 let's say server is running on port. We can put it like this, right? It's
16:04 going to get the variable and you can open up your terminal. It is still working as expected. Now another
16:11 environment variable that you would like to have is node env which says if you're
16:17 in development or in production since we are still developing this application this is going to be equal to development
16:24 but once we deploy it this will be equal to production right and if you don't know what that means I'll just show you
16:30 that once we deploy the app. Okay, so this is the basics. I think this is the
16:36 basics of our codebase so far. We have a DMV file, a front end folder, um a
16:43 backend folder. Everything is set it up. We can test our test out our API with
16:49 the get requests, right? So they are get requests because from the browser, we
16:54 can send get request to these URLs at the moment.
16:59 All right. So everything is working as expected. Now just before we end this section I would like to optimize this
17:06 codebase a little bit more because currently if you take a look at it we have three different endpoints. In the
17:12 future we will have more let's say API oath maybe something like update profile
17:18 right and every single one of these endpoints will be let's say 50 lines of code this is going to be you know 70
17:26 lines of code so on and so forth. test file is going to be unmanageable. So for
17:31 that reason, we don't really want to put our endpoints like this, right? So we're
17:36 going to put put them under the routes. So these are related to authentication.
17:42 For that reason, I will create something like oath.js file. Now this is what you can create.
17:48 But I'd like to follow a convention. Basically, I'll say oath.oute.js.
17:54 So this is the same thing as saying oath.js. JS right the extension is still
18:00 JavaScript but I'll just put this so that you know I have this kind of a file
18:06 structure I can just see okay this is a rod file that is related to authentication okay now let's see how we
18:13 can clean up this codebase basically first we'll say import express from
18:19 express and we are going to create a router we'll say express router and then
18:24 we'll say export default this Now instead of putting you know login,
18:30 log out and sign up here we are going to delete them. So let me copy all of them
18:36 and paste it right here. And instead of app we have router. So let's just say
18:42 replace them with the router. Right? So router.get on this endpoint we're going
18:48 to send this uh send this response. Same for this one and this one. Now let's
18:54 save here. Instead of having all of them, I will say delete everything. I
18:59 know that it's kind of confusing, but it's going to make sense. Let's say app do use.
19:05 So, slash API/ oath. So, in this case, we would like to
19:10 import this file. So, let's try to first import it. I'll say import oath routes
19:16 from this file. And make sure to put the js at the end. Otherwise, it's not going
19:22 to work. Since we are importing a local file from our codebase, you should put the extension at the end. So, here I'll
19:29 say oath routes. Now, since we have / API/ oath here, we can delete it from
19:37 this file. So, I'll go ahead and delete them. Now, let's see what we have done. I'll just put them side by side.
19:46 Okay. So, this is the server.js js file and this is the oath route oath route.js
19:52 file. Now if user sends a request to localhost 3000/ API/ oath slash signup
20:00 they're going to see this result. If they send to /lo they're going to get this one and same for the logout. So
20:08 basically we took these and prefix them with / ai/ oath. Now this file is a lot
20:15 more cleaner and we put every single route to this specific file. Let's take
20:20 a look at the terminal. We don't really have any errors and let's test it out. I'll send a request to / API/ oath slash
20:29 signup and see if it is going to work. I'll refresh. Right. So we're getting
20:34 the same response. Let's say login. We got the login endpoint and log out. Now
20:41 everything is working the same way but our codebase is a lot more clean right a
20:47 lot more cleaner. Now what we can do in the future if we want to add something related to messages we can basically
20:54 duplicate this and say API messages and we can just say import the message
21:01 routes right and we would do the same thing from here let's actually do it
21:06 I'll say message routes so from this file let's say message route.js JS just
21:14 something that we will create and let's get the same um setup express
21:21 from express create a router
21:26 let's type this out and for now we can say export default is router and for now
21:33 I'll just say router.get get so slash API slash messages let's say slash send
21:41 and I'll say something like send message endpoint right okay so this is what I'll
21:47 have and I think we can save this take a look at the terminal no errors let's test it
21:55 out slappi slash messages send okay send message endpoint now our
22:02 codebase is a lot more cleaner. Everything that is related to authentication is in it in its own file.
22:10 Same for the messages. And if you can imagine like maybe this project would be really really large. You can put all of
22:17 your routes into this folder and just simply import it. Okay. So I hope that
22:23 makes sense. We basically prefix our routes with whatever whatever that we
22:28 have here. All right. So I think that's it for this entire section where we set
22:33 it up our API and our front end application. Now just before we end it,
22:39 I would like to create this as a git repo and push it to our GitHub account.
22:44 Right? So here under the let's say under our terminal, I'll kill this and under
22:51 the root I'll just say get in it. And I'd like to basically have a get ignore
22:58 file under the root.
23:03 And here in this file, we would like to ignore the node modules as well as the
23:09 env file. So if you save now, you're going to see that node modules have been
23:14 grayed out as well as the env file because we don't really want to push
23:20 this file to GitHub. We have our secrets here, right? This file should be only
23:25 visible to ourselves locally in our laptop. Okay. Now let's say get add
23:32 everything and get commit dash m something like project or I'll just say
23:40 initial commit and we're just going to commit this. Now
23:45 in the upcoming sections we will actually create separate branches and
23:50 send pull requests. Since this is the very first commit I'll just have it in the master branch. Now let's go and
23:58 visit our GitHub account and create a new repository. So from here select new repository. For
24:05 the name I'll just say chatify. You can put anything that you wish and you can leave it as public. For now I'll make it
24:13 private. But once I publish this video, it's going to be public. So while you're
24:18 watching this video, it's going to be public. So let's say create the repo
24:23 here. We'll just scroll down, copy this, which says if you already have an existing repository, just go ahead and
24:30 push it. In our case, we have one, right? We have initialized it. We'll just paste this in and it'll take our
24:38 code and hopefully push it to this repo. Okay, so here we can see we have the
24:44 entire codebase but we cannot really see the env file as well as the node modules
24:50 which is what we have like this is what we want. We ignored it in the first place. Okay, so that's it for the very
24:58 first section. I hope it wasn't really confusing. I tried to make it as beginner friendly as possible and try to
25:04 explain every single concept that we have used here. Um, if there are things that you don't understand, I think it's
25:11 going to make more sense in the upcoming sections. So, for that, I mean, I'll just leave it here and hopefully see you
25:17 in the next section. This course is kindly sponsored by
25:22 Savala and Code Rebbit. They both have free plans, so you don't need to pay anything to be able to follow along with
25:29 this course. Thanks for watching and let's get into it. So, this is where we left. We have a
25:36 pretty basic API that we have just built in the previous section and we have a
25:42 react application. Now I would like to take this app and deploy it so that in
25:47 the upcoming sections we can see the live uh end result on the internet right
25:52 not just on local host. To be able to deploy this we'll be using a platform
25:58 called Savala. You can find the link in the description to get $50 for free. So
26:03 you don't really need to pay anything to be able to follow along. And Sabala is a platform where we can deploy and host
26:11 our applications, storage, and databases. In this case, we'll be using it to be able to deploy our apps. Now,
26:18 we can't really use something like Versel or Netlfi for this application
26:23 because in the upcoming sections, we are going to have scikit.io in our back end.
26:29 and uh like versel and netlifi doesn't really support psych.io So for that
26:35 reason we'll be using Savala with the link. Go ahead and sign up with your GitHub account. This is what I have
26:42 done. Now I'll go into my dashboard. So you can deploy any kind of application
26:47 and you have even like demo applications. If you just click to it, it's going to deploy them. But we'll
26:53 just do it from scratch. And just before we deploy it, I'd like to, you know,
26:58 show you some concepts or explain some concepts. Now what does that mean? So
27:03 this is the current state of our application right we are running our back end under localhost 3000 and I mean
27:11 localhost 3000 and in the front end we have it under the 5173.
27:18 Now what I'd like to do instead of deploying these separately I will just
27:23 take the front end let me just shrink this. Okay so I will serve this from the
27:28 back end. So we will have only one URL. Let me do it once again. So instead of
27:33 having something like my backend.com and my front end.com,
27:43 I will have something like myapp.com, right? I'll just say my chatapp.com
27:50 and that's it. So we don't really need to deploy this twice. I will get the
27:56 front end and serve it under my back end which is going to be just one URL. So
28:02 from the back end we can both serve our API endpoints and we can serve our react
28:09 application right let's say our static assets which is our react application
28:16 right our front end and to be able to make this work we just need to write a little bit of code and let me try to
28:23 walk you through it so we're going to write this code under the back end under the server.js JS file. First I will open
28:31 up my terminal. So this is what we had in the previous section. Let's open up a new one. Under the root I will say mpm
28:39 init-y. Now we are not going to install any packages but here we will have some
28:45 scripts so that we can uh prepare both the back end and front end for
28:51 deployment. Now in the like when you want to deploy a react application this
28:58 is what you would like to do. You would first cd into the front end
29:03 and you would say mpm run build. This is going to take your react application and
29:09 make it production ready. Right? It's going to optimize it and put everything under the folder. So this is your react
29:16 app but it is the optimized version. Right? Okay. So everything has been served under the index.html file. Now we
29:26 are going to have this this folder which is going to be our front end. So I know that this is kind of confusing but I
29:32 promise it's going to make sense in a second. Okay. Now let's go ahead delete the test and just remember we have
29:39 index.html file. So we would like to run this build
29:46 script under the front end. And just before we write some code, I'd like to
29:52 show you our GitHub repo. Let's say this is the repository, Savala is going to
29:59 take this repository to be able to deploy this application. But for Savala
30:05 to be able to deploy it, it needs to have the node modules both under the back end and under the front end. So we
30:12 need to run mpm install in both of these folders, right? both under the front end
30:18 and back end. So how can we let Savala to do it? Here we will basically have a
30:24 build command. We will say hey Savala just go ahead run mpm installed but just
30:30 make sure to run it under the back end. So we'll say prefix back end and then we
30:37 will say now that you have the node modules for back end just go ahead run the same thing under the front end. So I
30:44 will copy this, give a space, paste and I'll say run this under the front end.
30:52 Front end. Now right after this you would like to get the test folder under
30:57 the front end. And to be able to get it we just typed mpm run build right under
31:03 the front end. So we will say once you have uh once you have installed the packages say mpm run build and do it
31:13 under the front end. Okay. So this is our build command. Savala has everything
31:18 that it needs. It just needs to run this application. So we'll say you need to
31:23 have the start script. Just go ahead say mpm run start but make sure to run this
31:29 under the back end because back end is our entry point. Okay. So that's the
31:34 first configuration. I hope it wasn't really confusing. Once again when Savala
31:40 takes your source code to be to be able to deploy it, it needs to get the note modules. So we're going to have the
31:46 build script so that it can install the node modules for the back end and for the front end and also for the
31:53 production ready react application it needs to get the folder and we're just going to say run
32:00 the mpm run build under the front end and to be able to start it just run mpm
32:07 run start under the back end we're just going to run this script.
32:13 Okay. So, under the server.js, we're going to just write maybe five lines of code to be able to make this ready for
32:20 the deployment. So, I'll have this file open. I will get
32:25 this uh let's say their name. I was going to say constant. Okay. Let's say
32:30 their name. And the the value is going to be equal to path dot result. And we
32:38 need to import the path. Let's say import path from path. Now, we didn't
32:43 install this package because it is built into node. We don't need to install it.
32:48 Right? After all of our API endpoints, we will say something like
32:55 make ready for deployment. Right? And I'll say if let me just kill this AI. It
33:02 is kind of annoying here. I'll say just notices for maybe 20 minutes. Okay. I'll
33:08 press command shift P. This is how I open the like this tab and I'll say toggle statusbar visibility.
33:16 So I'll say if process envode
33:21 env is equal to production which means we are in the deployment
33:28 right here I'll say app do use just follow along with me it's going to make
33:34 sense in a second. Let's say express.static. And here we would like to pass
33:39 path.join. And within this I'll say underscore their name and put a comma. We'll just
33:47 go one up under the front end slashist.
33:52 Now what does that mean? Basically we would like to take our dist folder under the front end and make it our static
33:59 assets if we are in the production. So here we just went up because we are
34:05 here, right? So we are here under the back end. We went one up. Now we are
34:11 here. Let me do it again. We are under the back end. We went one up. We are
34:16 here. From here we went under the front end. And then we got the folder. Now
34:21 this is our static assets. So once again here we had to go one up because we are
34:27 currently under the back end. we went one up then slashfront end and then
34:32 slashist. Okay, so this is our static assets and if we want to have the react application
34:39 we just say app.get. So any other routes other than our API
34:44 routes, right? Any other thing other than API we would like to serve our
34:50 index.html file. So I'll just say here have the request and response. This is
34:57 basically just a controller. We'll say res.end file. And the file that we're
35:03 going to send is going to be path.join. And again, we will basically do the same
35:08 thing. Let me copy this. Paste this in. This is going to be test/index.html.
35:18 Now, if you wanted to, you can make this also a string separated or commaepparated. I'll just say their name
35:25 front end and put a comma. Let's say go under the test and under here just go
35:32 ahead get the index.html file. So this is that file I showed you
35:37 if you remember right just go ahead save this and now we can test this out. I
35:43 will go ahead under the envu
35:51 and we are going to run this app. Let's kill all of our terminals
35:56 from here under the root. First I'll say mpm run build. So this is what savala is
36:02 going to do as well. Let's delete the node modules. Right? This is what we have in our
36:09 GitHub repo. Let's say npm run build. So it's going to get the node modules now
36:14 for back end and for the front end. And it also got the desk folder, right? And
36:20 then we can say mpm run start which is going to run the start command on back
36:26 end. Okay. Now it says server is running on port 3000. So when we visit 3000
36:34 normally we would see our API but now we can see our react application right.
36:39 This is exactly what I have explained under one domain which is for now is localhost. we can get both our react
36:46 application and our API. So here if you visit slash API/ oath signup you're
36:54 going to get the signup endpoint but if you visit something else you're going to get the react application. So this is
37:00 exactly what we have explained right here and this is what we have type right
37:06 say anything other than these you should send the react application okay so
37:12 believe it or not that's entire thing for authentication sorry for deployment not authentication this is the entire
37:19 thing for deployment we can now just deploy this and just a quick thing that I'd like to mention here we are not
37:25 using the request right so you can put this as an underscore for this is just a commission that you can keep in mind if
37:33 you haven't seen it. Okay, what have I done? I think I didn't do anything
37:38 wrong, right? Accidentally pressed it, but okay, I think we're fine. Now, we would
37:45 like to take these changes and push it to our GitHub repo. Um, here I'll open
37:51 up the terminal. So, I will open up a new terminal and just push my changes.
37:57 I'll say get add all get commit-m let's say ready for deployment
38:06 say deployment okay so this is what I have typed
38:14 and commit this now we'll just say get push and here there is an extension that
38:19 I'm using just before I say get push I'm using code rabbit's uh vs code extension
38:25 which is going to review your changes this if you really wanted to. If you want to test it out, you can use the
38:30 link in description. It's going to give you 14 days free trial and we're going to be using it in the upcoming sections.
38:38 So, just keep this in mind. You have the VS Code extension as well if you want to get this.
38:44 Okay. So, this is the one that I have installed. It is free to use here in VS Code. Um, if you go with the link in the
38:51 description. Now, I have my commit. I'll say get push. And after this section, we
38:57 are going to create new branches for the new commits, right? We are going to create pull requests. So say get push
39:05 and let's take a look at our codebase. So we just got the latest changes. Right
39:13 now we would like to go under the Savala. I will say under the dashboard
39:19 maybe applications create a new application. We're going to get it from
39:24 our GitHub repository. And here from the repositories, I selected the Chatify
39:30 repo that we just created. And here I'll just select this checkbox which says
39:36 automatically deploy on new commits. Just make sure to select it so that you
39:41 don't really need to deploy this app again and again. So this is the location that I have. We can change it, put it
39:48 anything. I think this is the one closest to me at the moment. Under the resources, I will get the $5 per month,
39:56 but we have $50 for free. So, feel free to select it. You don't need to pay
40:01 anything. Okay. So, I'll just say create and I
40:06 think should we say like create and deploy? Um, I think I'll just say create for now because we we need to put some
40:14 environment variables. So I'll copy everything.
40:20 Go under the environment variables. Let's say add. Paste this in. Now we can
40:26 delete this one. We are not using it or you can leave it. It's not really important. NV is going to be equal to
40:32 production. And you can leave your port. So even if you delete it or not, that's fine. In the future, we are going to
40:39 update this value. So actually I'll just delete it for now because we don't really need it. Now just have both of
40:45 them. Let's say save. Okay. Now we can go I think under the
40:52 overview and we can just say deploy. Now
40:58 okay let's say master branch deploy the application.
41:03 This is going to take couple of minutes. Once it is done I'll just be right back and you can uh like click to it and see
41:09 the logs. So here it's going to have couple of different um couple of different steps.
41:15 Once it is done, we should be able to visit our application. So this is my URL. In your case, it could be something
41:22 different. But then once it is done, we should be able to see the end result. So
41:28 let's wait for this to be completed. So in my case, for some reason it has failed. It says we cannot see the vit.
41:35 SVG, which is something that we have right under the front end source. I
41:43 think the assets or even public we have the vit.svg. So I don't know why this is the case.
41:49 For that reason I'll go ahead and give it a go. Once again under the deployments I'll say redeploy.
41:57 Let's say redeploy the changes. Hopefully it should be working out
42:02 correctly. If not we can see a different solution. So it has just failed again.
42:08 And I just realized it says let me zoom in. So it says you are using NodeJS
42:14 version 18 but V requires Node.js version 20 or 22 plus. So please upgrade
42:21 your Node.js version. Now this doesn't mean in your local machine but in the package.json.
42:27 So here under the root right after the main I'll put something like this we'll
42:32 just say the Node.js should be the Node.js version should be greater than
42:38 20. Right? So under the engines just put this configuration and we would like to
42:43 add a new commit. Let's see if this is going to fix it. Now we are getting some errors. That's completely fine. This is
42:50 how real world programming works. You get some errors and try to see come up with like try to come up with solutions.
42:57 Right? So I'll say get add all get commit-m let's say node
43:04 or maybe engines field added
43:10 in package JSON okay I'll say get push
43:15 we can have a quote suggestion or a review but for now I'm going to ignore
43:21 this in the upcoming sections we'll be doing it now we have committed and we
43:27 say get push. Now if you take a look at under the deployments there is a new
43:32 deployment that is happening and this is the beauty of Savala in this case on
43:37 commit we will get automatically deployments and let's wait for this to
43:43 to be completed and let's see if we are going to get any errors or not. All right so looks like this time it did not
43:50 failed and deployment has done successfully. So here that was the point we were getting the errors but now we
43:57 don't and it says server is running on this port. Now you might be asking we just said 3000 why this is 8080. Um this
44:06 is because what Savala uses they use dynamic ports which is completely fine.
44:11 We don't really want to run it specifically on 3000. So it is not a problem. Now let's say visit the
44:18 application. Okay. So this is our react app. It is working correctly. We can say slash API
44:25 slash oath slash something like sign up. We can get the signup endpoint. And
44:31 later in the video we are going to build the signup endpoint which is going to allow us to basically sign up right make
44:38 the user authenticated save the user to the database so on and so forth. Same
44:43 for the login check for the credentials etc. Now everything is working. we have
44:50 our own domain and under this we can get both our front end and our back end.
44:57 Okay, I hope it wasn't really confusing. Let me pretty quickly walk you through it what we have done in this section. So
45:04 under the package JSON under the root we have created two different scripts which
45:09 is the build and start scripts. The build script is going to install all the
45:14 packages for the back end and front end because in GitHub we don't really have
45:20 node modules. They have been deleted. So this is going to install it. Savala is
45:25 going to install it and then it's going to build the front end folder and that
45:30 build is going to give us the test folder. Right? This is our React application that will be served which is
45:38 the optimized version. And then under the back end we have the server.js file.
45:44 We have written like five lines of code where we make the test folder to be our
45:50 static assets. And we said everything on everything other than our API endpoints
45:56 should be served as the index.html file basically right which is our react app
46:02 our front end. Okay. So I hope this wasn't really confusing. At the end of the day, we have only one domain which
46:10 is serving both our API and our front end, our static assets. So with that,
46:16 that's going to be for this entire section. Hopefully, I'll see you in the next one.
46:22 So in this section, we'd like to connect to a database and then make the authentication routes work.
46:28 Specifically, we're going to build the sign up endpoint. So user will be able to sign up where we save them to our
46:35 database and then authenticate them and maybe even send them a welcome email. So
46:41 we're going to get into it but first we need to set up a database. Now if I were to use something like Postgress or my
46:48 SQL then I would just grab it from the Savala databases. So they have couple of
46:54 different options and this is pretty cool because you can have your deployed application as well as your database in
47:01 the same place right you don't really need to go anywhere else and to make them work together instead you would get
47:08 everything in one place but in this project as we promised we'll be using
47:13 MongoDB so head over to head over to mongodb.com and create an account I
47:19 already have so I'll just try to log in
47:25 and then we are going to create a database and then hopefully connect to it
47:30 and maybe in one of the upcoming projects we could use these databases and deploy our application into the same
47:37 place so that you can see the benefit. So definitely feel free to play this. Um
47:43 if you want to have radius or wall key marb probably you have never tried these
47:49 maybe this is a pretty good option uh where you can basically experience
47:54 it. So here let's try to create a new project. This is the very last one that we have
48:01 created but let's say view all of them and we are going to create a new one. So
48:07 I'll say chat fi. You can put anything for the name.
48:14 And then we would like to create a free cluster. Again, you don't need to pay anything. So, just select this, leave
48:22 everything as it is, and say create the deployment.
48:28 Okay. So, make sure that you copy and uh copy the password and this is the database user. Let's say create that.
48:35 Choose a connection method. Let's say drivers. Now it says you
48:41 should install MongoDB but we are using we are using mongus so we don't really need to install it. All right. So once
48:48 again we'll be using mongus not the MongoDB driver. Um here we copy the
48:54 password. I think we can just copy the connection string because the password is already within this right. So this is
49:00 your password. You can toggle this. Okay. So just copy this and go under the
49:07 MV file. Now we will put the actual connection string. So just paste this in. By using this we can connect to our
49:15 database. So let's say done. And then we just need to do one more thing under the
49:21 network access. So here just say add the IP address and say allow access from
49:28 anywhere. Just say confirm. This will take couple of seconds and then it should be active. Here we go. So now we
49:35 can go under the database clusters and we can say browse collections but we
49:40 don't really have anything so we'll just get nothing right. Okay. Now maybe it is time to connect to our database and
49:48 handle the users sign up functionality. So first under the source I will create
49:54 a folder called lip and within this I will have db.js js file which is going
49:60 to allow us to connect to our database. So I'll say import mongus
50:07 from the mongus package right and then we're going to have a function let's say
50:12 const connect db this will be an async function and we're going to have a try
50:19 catch block. So under the try we can say something like await mongus.connect
50:25 connect then we're going to put the process envongo
50:32 uri. So this is going to connect to our database by using our connection string
50:37 right and then we can say something like console log mongod db connected
50:44 successfully right and here we can even get the connection let's say con um here
50:52 I'll say the host right so I'll say connection connection host so this is
51:00 just something if you don't have in the terminal. And in the catch, we can say console log or even console error.
51:09 Let's say error connecting to MongoDB.
51:16 And we can put the error right here. Now, since this is failed, we can just say process.exit
51:23 with the status code of one. I'll put a comment. One status code
51:30 means fail, zero means success. Okay, just keep that in mind. So this is
51:37 the function that we have created. We are going to run this once we start listening our application. I will cut
51:44 this for a second and here let's say you know server start um on this port
51:51 and then go ahead call the connect DB method.
51:56 which is imported from this file. Make sure to put js at the end. Okay. Now
52:02 let's try to run our application. So here I'll go under the back end. Let's
52:08 say mpm rundev. And just make sure this is equal to development. That was just
52:14 for testing purposes. We're actually in development here, not in production.
52:21 Okay. Server started right. It is running. And then a couple of seconds later, MongoDB connected and this is our
52:28 host. Okay, so MongoDB has been connected. Right now it's time to build
52:34 our route. Now again, instead of having the function here, instead of having
52:40 like 100 lines of code here and then another here, what I'd like to do is
52:46 basically cut this and put it under the controller. So I will cut this function
52:52 which is basically a controller. Okay, for some reason okay I just cut
52:58 that. I will put it under the controllers. Let's say oath.controller.js.
53:04 And this will be a function. Let's say export cost signup
53:10 and just paste this in. Okay, so it's the exact same thing. We can even make it async if we really wanted to. Let's
53:17 say once user hits this endpoint, we're going to get the signup controller from
53:23 Ocontroller.js file. Once again, put the extension at the end. And this is going to be a post
53:30 request, not a get request. Right? So, if you save it, hopefully we shouldn't really
53:36 have any errors in the terminal. Now, if users wants to sign up, they would like
53:42 to send couple of different fields, right? This is a screenshot under the sign up page. This is what we're going
53:48 to have at the end of this tutorial. But basically, if user wants to sign up, they need to send the full name, email,
53:55 as well as a password field. But to be able to grab these fields under the back
54:01 end, under the server.js, we need to add this line. So here, right after the
54:07 port, just say app. Express.json.
54:12 So this is a middleware that we are calling so that we can get access to the fields that user sends. So it is going
54:19 to be under the request body. Okay. So let's see what I mean. Under the signup
54:27 we have request right we would like to grab the fields that user will send us
54:32 things like full name. Let's actually grab this. I will delete this response.
54:38 So here I'll say const we're going to get something from request dot body which is going to
54:46 be things like let's say full name it's going to be email and password.
54:52 If you didn't put this line right if you delete it this is going to be equal to undefined. You cannot really get them.
54:60 So for that reason make sure to add this and let's close these files. Okay, so
55:06 here I'll have try and catch block. Let me kill the left hand side and maybe
55:12 zoom in again. Okay, so under the try before we save the user to our database,
55:17 I'd like to do a couple of different checks. So first I'd like to make sure that if user filled in all of these
55:25 fields. So if they didn't provide full name, we'll just say hey you should provide this one and same for these.
55:31 Then I would like to check if they put a valid email. So if they put something like ABC at Gmail so this is not a valid
55:42 email account right it should be ending with something like com you know com or
55:47 anything right? Um so we will just check for these kind of thing here. I'll say
55:53 if there is not full name or if there is not email
55:59 or if there is not a password. In this case we would like to just immediately return out of this function and send a
56:06 response. So this is going to be an error. So we'll say status. So the status code is going to be 400 which
56:14 means a bad request, right? And then for the message we can say something like
56:19 let's say JSON message let's say all fields are required. Okay. So that was
56:26 the very first check. The other one that I'd like to have if the password is
56:32 let's say length if it is less than six we don't really allow this to happen
56:37 right we want to keep our application a little bit safe. So I'll basically duplicate this and I'll say
56:45 password should be at least six characters, right? Say password must be
56:52 at least six characters. Okay, so that's the
56:57 second check. Now the third one is to check if the email valid I mean email is
57:03 a valid address, right? I'll say check if email is valid. And for this we'll be
57:10 using regular expressions reax. Now let's see what does that mean. I will
57:15 copy and paste two lines of code and I'll tell you where you can grab these. For now just watch me. Okay, I'll just
57:23 save. So there is some gibbreish code which is like a regular expression and we will say
57:30 let me format this a bit. Okay. So here it says just test out the
57:37 email that user sends us. If it is not valid, we will say invalid email format.
57:44 So this looks really confusing and to be honest, if you delete this and ask me to
57:50 type this out, I cannot really. So this is something that you don't need to memorize and I don't even know either.
57:56 Right? You can grab this from the source code. Visit the O controller file and
58:03 find this code. just copy and paste it. This is something that you would get normally from AI or from somewhere like
58:11 Stack Overflow, but nowadays you would just get it from AI. Okay, so that's our email check. And then we can have
58:19 finally the user, right? I'll say const user. Now we would like to check if this
58:24 user already existed here. Let's take a look at the UI. So
58:29 let's say if user wants to sign up with an email like johno@gmail.com
58:35 but if this email already existed we'll just say something like try a different
58:41 email right so again we will have some checks but now how do we get this user
58:46 from the database just before we build it we need to create a model it's going
58:52 to be pretty basic let's go under the source create the models and we would
58:57 like to create a user js file and just make sure that the u is uppercased. This
59:03 is one of the conventions that we can follow. The other one is user.mod.js.
59:10 Again, this is just a regular JavaScript file. The icon changes because of my VS
59:15 code theme. Um but it is just the same thing as doing this one. Here I'll be
59:22 using this convention user.js. Okay. So we will create a user model so
59:28 that we can communicate with our users in our database and let's see how we can
59:33 create this one. So if you have ever worked with MongoDB then you know how to build it but if you haven't I can
59:40 explain it from scratch. So first we are going to import mongus and we are going
59:45 to create a schema. In this case it's going to be user schema and we'll say
59:50 new mongus schema. Let's say call this and then we are
59:57 going to pass an object. So we will say every single user will have an email and
60:03 this is going to be type of string. So just say type will be string
60:09 and it should be with upper like capitalized type will be string. Let's
60:14 say it's going to be required. So require true and duplicate this. It's
60:20 going to be also unique, right? Let's say unique will be equal to true. Now
60:25 we'll do the same thing for full name and password. I'll just duplicate this. Let's say full name is going to be type
60:33 of string required but it doesn't have to be unique. Let's do the same thing for the password and profile pick. Let's
60:41 say password type string required. It shouldn't be unique but we can say
60:46 something like minimum length is going to be six. And then for the profile pick
60:53 type string, it doesn't have to be required. And by default, we can just
60:58 say it's going to be an empty string. When user signs up, it's going to be an empty string. And then if they wanted
61:04 to, they can update it. Now, also, this is optional. I always um add it the
61:10 second object with the timestamps to be equal to true. So, this is going to add
61:16 created at. Let me type this out. Created at and updated at fields to the
61:25 user. So you can use this field to show something like user is member since this
61:32 date, right? And then you can use this to show something like last login and
61:39 you know the updated updated date whatever that is. Okay.
61:44 So we have the schema. Now we would like to create a model here. I'll just scroll to the bottom. I'll say const user. This
61:52 is the actual model. We'll say mongus dot model. It's going to be the user
61:58 model. Just make sure to type it out like this capitalized. And then we will
62:03 say user schema. So this basically says create a user model based off of this
62:09 schema that we have. So that every user has an email, full name, password, and profile p. And then finally we'll say
62:16 export default user. Okay. So by using this import
62:24 right by using this user object we can interact with our users in the database.
62:30 So this is what we'll be doing under the oath controller. So here I'll say const user
62:36 can say await user dot find one
62:42 and we need to import the user.
62:50 So we'll say user from we'll just go one up under the models user.js. Once again
62:57 make sure to put the extension at the end. So we'll say find one user where the email is equal to this email that
63:05 user sends us from the sign up form. Since they're the same thing, we can shorten this. Okay, so this is the user.
63:12 We'll say if there is a user, then we can just return immediately and
63:18 say resa status of 400. And we can say JSON
63:24 message of something like email already exists,
63:31 right? So please try something different. But if this is not the case, we can take the user's password and hash
63:38 it. So let's say user has this password. We don't really want to save it as it is
63:43 to the database. We would like to you know make it something gibberish like let's say dollar sign some letters
63:52 underscore like not exactly like this but it will be something unreadable. You
63:59 don't really want to save it as it is. So this is what we call password hashing and for this we have installed a package
64:06 which was brypt. Let's say import brypt
64:11 if I can type it out. brypt from bryptjs.
64:18 Okay. So now we'll be using this. I'll say con first you need you need to
64:25 create a salt. Let's say await brypt. Gen salt. So brypt.gen salt. And we're
64:33 going to call this method by passing 10. So this 10 is going to determine how long the string is going to be. Now you
64:41 might say okay let's make it 100 so that is really secure but then this will take a lot longer than 10. So 10 is a perfect
64:49 value that we can use. And then I can say const hashed password. We will
64:56 basically say await brypt.
65:02 Let's say brypt dot hash just call the method. We will say hash this password
65:08 that user sends with the salt that you have. Okay. Now that was the password
65:15 user sent us and this is the hashed password. It is this value. I hope that
65:22 makes sense. Now we will say um basically create the new user.
65:29 So I'll say new user call the class the user model and then we'll say as the
65:36 full name here is the email and here is the password. password is going to be
65:42 the hashed password. Right? Okay. Then we can go ahead basically say if there
65:48 is a new user we can do something else we can throw some kind of end there
65:54 error right I'll say raza status of 400 and then here I'll say JSON something
66:02 like message invalid user data. Now in the if case we
66:10 can basically say generate token. So this is going to authenticate the user
66:16 which is something that we're going to do. We don't have this function. We are going to create it. Let's say we would
66:23 like to pass the new user ID
66:28 and also the response. You're going to see why in a second. And then we can say
66:33 wait new user save. So this is going to save it to the
66:40 database. Then finally we can say res status of 201 which means something is
66:48 created right and then let's say JSON. So 200 means success and 201 means
66:55 something created successfully. And for the response we can basically send the
67:01 ID of this user. Let's say new user ID. We can send the full name. So these
67:08 are the things that we sent back to the client to let the user know that they are like they signed up successfully.
67:17 Let's pass the email. I think I can just duplicate this and we'll do the profile pick. So here I'll say email.
67:29 Okay. Now let's say if I think our server is going to crash or maybe it doesn't. But
67:36 if you call this method, it would crash because we don't have this method. And just before we create it, let's handle
67:43 the catch case, the catch block. I'll say console.log something like error and signup
67:50 controller. Let me turn this down. Say controller
67:57 and put the error. Then we can say res status
68:04 of 500 JSON and we can say something went wrong as our message. Right?
68:14 Let's say internal server error. Okay. Now we need to
68:20 create this method. I promise once we create it we can test this out and everything should be working out as
68:26 expected. So I'll copy this name. We will go under the lab. We can create some utils.js
68:34 file and create this method. So first we are going to import JWT from JSON web
68:41 token. This is the package that is going to allow us to implement the authentication and then we can create
68:47 this method. So this was getting two different arguments if you remember right. We passed the user ID as well as
68:55 the response. So let's double check this is the user ID and then the response.
69:00 Now here basically we would like to create a token for the user right so that we know that which user is which
69:08 one and if user is authenticated or not. So let's first type this out and then
69:13 I'll show you some kind of a diagram that I have here. You can access them
69:18 under the like in the video description. Let me actually walk you through it first and then we can write the code.
69:26 Okay, so this is our authentication workflow. User is going to click to a button which is going to send a request
69:33 to our endpoint which is like API o signup or login right. So then if it is
69:41 the signup case we would like to create a user in the database and then generate
69:47 a token right. So we are going to save the user to the database and then generate a token and this token is like
69:55 saying user that hey you're authenticated just keep this token with you. So we will create it from the
70:02 server and send it back to the client and since we are sending we will be
70:07 using response right. So that's why we are getting the response in the first
70:12 place because we'll be using it here. So we created the token. We are going to
70:17 send it as the response back to the client in the quickies. Okay. So just
70:23 keep this in mind. We will create the token and send it back in the quickies to the client and we can show some kind
70:30 of a success message like you signed up successfully. Right? Okay. Then there is
70:35 another part. This is to check if user actually authenticated. This is something that we'll get into. For now I
70:43 want you to understand only this part. User will send a signup request. We are
70:48 going to save it to the database. Generate a token and send this token
70:54 back to the client with the response. Okay. So it'll be under the quickies.
71:00 So let's see how we can create this token. I'll say const token and here
71:06 we'll say jwt sign. here this wants you to have three different objects right so
71:13 the first one is the payload I'll explain what that means let's say user
71:18 ID and we can just pass the user ID as we are getting so we can say like
71:24 anything but in this case it should be something meaningful so with this user
71:29 ID we can basically know which user owns which token right so this is like an
71:36 identifier and since they are the same value we can shorten this. The second object is the secret key. Here we can
71:44 see secret or private key and we are going to get this from MV file. Let's
71:49 say JWT secret and then we're going to pass the
71:56 option. Let's say this will expire in 7 days. So just put 7D.
72:02 Okay. Now let's try to create this under the env file. For the value, you can put
72:08 anything. For now, I'll just say my JWT secret.
72:14 Okay. So, we created the token. Let's send it back to the client with the
72:20 under the cookies. So, I'll say resquickie. The name it could be anything. I'll say
72:27 jwt. Just follow along with me so that we can have the same codebase. I'll say
72:32 pass the token. This is what we would like to set, right? the name, the value and then some options to make it a
72:39 little bit more secure. So for the first key I'll say maximum age I will say this
72:46 is going to be 7 days but you cannot say 70 here this should be in milliseconds.
72:53 So I'll say 7 * 24 * 60 * 60 * 1,000. So this is in
73:02 milliseconds once again. Okay. So this is like 7 days. And then we can put the
73:08 HTTP only. I'll say true. This is going to make it
73:14 to be a little bit more secure. And let's say prevent like this will prevent
73:19 the XSS attacks. So that means this token is only going
73:25 to be available via HTTP with a JavaScript. No one can access to the
73:31 token. And this is what we call the cross site
73:37 scripting. So this is the name of the attack. If you really wanted to, you can check this out. Scripting.
73:45 And then we have the same site. We'll say this is going to be equal to strict.
73:52 Again, this also let's say strict. This will also prevent
73:57 the CSRF attacks. You can check this out if you are really
74:03 interested in that. And finally, I will say secure. And this secure field is either going to be true or false. But
74:11 how do we determine it? Well, it's going to be depending on the environment that we are at. So if we are in development,
74:18 that means we have HTTP localhost, right? But if we are in production, we
74:23 have HTTPS some.com. So if like if it is in production, it is
74:29 secure, right? Right? We have HTTPS. So this S stands for secure. But if you are
74:35 in development, it is not secure, it is false. So that's why we'll just say if
74:40 we are in the development, this is going to be equal to false. But if you are in production, it's going to be equal to
74:46 true. So I hope that makes sense. This is what we're going to have. And finally, we just say return the token.
74:53 Okay, so that's pretty easy, I think. Write like 10 lines of code. We generate the token. Let's try to call it and make
75:01 sure to import it from the utils.js file. Okay. So, let's um let's save and
75:08 try to give it a go. I'll I'll be using Postman to be able to test this out,
75:13 which is a free desktop application. You can download. I already have it. Let me
75:19 put it right here. Let's try to create a new collection.
75:25 Okay, maybe I just need to zoom out. make it full screen.
75:32 Okay. So, let's put our endpoint which is localhost 3000 slash API/ oath
75:41 slash signup. So, if I just send a get request, it's not going to work. But
75:47 let's say post and under the body let's say row JSON
75:54 here let's try to send the full name field. So I'll say full name is going to be
76:01 John do. If I just sent the request it says all fields are required. That's
76:06 correct. Let's pass the email and I'll put a wrong email like just
76:13 John. This is not a valid email address. And let's put the password
76:20 and let's say from you know 1 2 3 that's it. First let's send the request.
76:25 Password must be at least six characters. Let's put it invalid email format. Right. Let's put
76:33 that in. Let's say John dogmail.com
76:38 send. Okay. User has been created successfully as you can tell. Um, and I
76:44 think we should have some cookies as well. I don't know if we can see it from here,
76:51 but okay. So, under here, under the cookies here, we can see we have JWT
76:57 token and this is going to expire in 7 days. Today is September 3rd and it's
77:03 going to expire at September 10. Right now, let's take a look at our database
77:10 if we have the user or not. Well, I'm pretty sure that we have it.
77:15 Okay. So, under the database, which is called test, I'll show you how to fix it. Under the user collection, we have
77:23 the user. And as you can tell, the password has been hashed. We just say from 1 to six,
77:30 but now it is something completely different, which is what we would like to have. Now, the database name is test.
77:36 Let's try to fix it. And you might be asking how can we fix it. Just under the env file before the
77:45 question mark you should put your database name otherwise if you don't put anything it's going to be test here.
77:51 I'll say chat like chatify db. Let's save
77:58 um just go here. Let's try to delete the test database.
78:06 Okay. Now we can create this user once again. It's been created.
78:17 Okay. For some reason, this name didn't update it. Well, it's because if you
78:23 update the env file, you should save one of your backend files. Okay, just save
78:28 it. Let's delete it once again
78:36 and sign up. User created. Okay, now we can see chat by DB and this
78:43 is the latest user that we just created. Let's try to create this user once
78:48 again. It should say something like email already exists. Now let's do Jane
78:58 Jane do this time. And if you don't pass the password again, it's going to say all fields are required. So everything
79:05 is working as expected. Here I'll just send the request. Chain has been created.
79:12 Let's try to refresh. We should have both of these users. And that means everything is working as expected. So I
79:19 hope you're able to see how everything works. Let's try to pretty quickly go
79:24 over it. We have API oath endpoint, right? And from here we have the signup.
79:31 We created a controller. Basically, we get all these fields from the user. And
79:36 to be able to get these, we need to have this middleware, right? And then we have
79:42 couple of different checks to make sure everything is working correctly. Then we got the password hashed it created the
79:50 new user and then generated a token. This token is basically creating a JWT
79:57 token by using this package and sending it to the client under the cookies. We
80:03 just add some options to make it secure. Save the user to the database and send a
80:09 response back to the client. Right? It's pretty basic. I don't really think if it
80:14 is any confusing, but here I'll just leave a to-do. Let's say send a welcome
80:22 email to user. So, I have a screenshot.
80:29 Okay. So, once user signed up successfully, we're going to send them an email like whatever their full name
80:35 is. In this case, it is like my name one two. and then some text with a link. So
80:43 if they click to this link, it'll take us to our application. So we're going to see how to build it.
80:50 This will be in the next section. But just before we end this one, I think we can create a new branch and commit our
80:58 changes. Right? So I'll kill everything. Let's close it all. I'll say command
81:03 shiftp and toggle the status bar visibility. And from here I'll create a
81:09 new branch. So here I think I can just call this as sign up. And if you join to
81:15 a new company, they're going to create a new branch for your for you. Right? This
81:20 this is what happened to me when I first joined to a company. They said we're going to create you a branch and you
81:27 will have your changes here. Once you do like once you commit something send us a pull request so that we can either
81:34 project your changes or accept it if we like it. So this is the similar process
81:40 that we're going to see. In this case we have a new branch for the signup section. Let's say create this one and
81:48 go right here. Just say add all these changes to the staging area and you can
81:54 shrink this one. For the commit message, we can say signup
81:60 controller add and I'll say commit.
82:05 Okay. Now we need to publish this branch. So this is going to publish
82:10 that. Here we can see without even refreshing we can get the new um like we
82:16 can create a pull request. Okay. Just make sure that like even you
82:23 don't need to make sure but this will be in default the base will be master and
82:28 you will be sending the pull request from sign up right. So this is what you would have in default just say create
82:35 the pull request. Okay, so your teammate would be coming
82:42 here and it would take a look at your code. If they like it or not,
82:48 you know, here they can add some comments. Maybe it would it would say this code isn't really clean, just go
82:55 ahead fix it a little bit. I don't know, any kind of thing. And they would say start a review. and then you would fix
83:02 it and then they can um let's say publish the branch or merge the changes.
83:09 I hope that makes sense. Basically, they can see your code and if everything is fine, they would just come here. Let's
83:16 go back again. They would just say merge the
83:21 pull request, right? But since this is our account, we can just do it ourselves as well. And here also you can see
83:28 something like code rabbit review in progress. If you don't know what that means, basically I have integrated code
83:35 rabbit to my repos so that I can get some suggestions. So this is your AI
83:41 senior developer teammate. Basically it'll give you all kinds of suggestions
83:46 any kind of critical bugs that you have in your code and it'll tell you hey you should fix this part. This doesn't look
83:53 correct. You have some potential issues. things like that. And especially if you're a beginner, you're not going to
83:59 you're not going to know all the best practices. So, it can give you all kinds of suggestions to tell you, hey, you
84:06 should follow this best practice or here in your code, you're linking some
84:11 credentials, things like that. And if you want to use it, you can find a link in the description which is going to
84:17 give you 14 days free trial without paying anything. No credit card required
84:22 at all. So every single time when you do when you do a pull request, it'll take
84:28 couple of minutes. Let's refresh. Okay. So it'll take a couple of seconds
84:33 and you should be able to get a summary by code rabbit with all the features that you have and then also it'll give
84:40 you some coding suggestions. So again it is taking couple of minutes. Let's wait.
84:45 Once it is done I'll show you how that would look like. All right. So just after a couple of minutes here we go. We
84:52 have an entire walk through of every single file with the changes that we have added and a huge sequence diagram.
84:60 This is actually insane. We can just zoom in and walk you through it what we have in this application. So first user
85:07 will send a pulse request to our signup endpoint where they pass full name,
85:13 email and password. Right? So we would check some validations like the email
85:19 format password length if user existed or not things like that right and then
85:25 if it is existed we would say user already exists but else we would hash the password create the user sign a JWT
85:34 token um or JSON web token with 7 days
85:39 then we would say you know 201 user created and here is the response that
85:44 you would get. And the other things that we have implemented are things like you
85:51 know the connect DB method. We pass our environment variable. If it is done
85:56 successfully, we would say connected to host. What else? Failure process exit
86:02 with the status code of one. This is insane. You can even put it into I don't
86:08 know into your website right after the project on the or in the readme file if
86:14 you really wanted to. This sequence diagram is really helpful. Okay, then
86:19 let's scroll to the bottom and see what kind of suggestions that we have. So first it is this one here. It says you
86:28 can get the name and check then trim this down. So basically it says if user
86:33 pass something like Jane couple of empty spaces you should delete these empty spaces and then save it to the database.
86:41 For the email, it says if user put something like Gmail all uppercased,
86:47 then you should take this lowerase it and then save it to the database, which
86:53 is I think pretty good suggestion, right? It says take the email, trim this down and lowerase it and then save it to
87:00 the database. So, this is something that you can do if you really wanted to. This is what that is.
87:08 Let's scroll a little bit down. Here we have a potential issue which says before
87:14 you generate the token make sure to save the user to the database. So let's do
87:20 it. I will copy this code. Go under the oath controller.
87:27 Let's close this here. Instead of having it in this way, I think he says do it in
87:33 this way. Okay. So first we are going to save the
87:39 user persist the user first then issue the oath cookie right okay let's say
87:46 before code rabbit and after
87:55 so looks like this is a better solution and here is the reason you can take a
88:00 look at that then what else do we have this is some suggestion I think this is
88:05 pretty extreme we can skip this. But if you want to have the best code, the most
88:11 beautiful code, you can copy this and add it into your codebase.
88:16 Then here under the db.js, we can implement this one as well. Basically, it says check if you have the
88:24 environment variable or not, you can go under the db.js.
88:30 So instead of doing it immediately, you would say if we don't have this in
88:37 the first place, if this is undefined, just throw an error, right? So this is
88:43 what they do, I think. So you can get this entire code if you really wanted to. I just want to keep it simple and
88:50 don't change our code base too much. So here it basically does the same
88:56 thing. It checks if token existed or not. Now this is actually a better code. I would recommend you to do it. So this
89:03 is a lot more better than what we had previously. And you can do the same thing under the utils file. So before
89:10 you add it here, let's do it. You would like to have this kind of a check
89:17 just before you create the token. So right here,
89:22 let's delete these plus signs.
89:29 Okay, we can delete the node DMB but here let's paste this in. Okay,
89:38 then let's see what else do we have. Now, of course, I'm not going to implement everything that Code Rabbit
89:44 has because I don't want to waste too much time. But as you can tell, how beautiful this is, especially if you're
89:50 a beginner developer, right? You would learn so many things just by reading
89:56 like 10 10 minutes reading this is a lot more better than watching a one hour
90:01 tutorial. You would see all kinds of best practices, the edge cases, things like
90:07 that. Okay, one more suggestion. It says before you start listening on your app,
90:13 maybe you can connect to the database and this is something that we can do in the future. for now just before I say
90:20 merge the pull request it will send another like these changes as a commit
90:28 here let's say sign up section let's say code
90:37 refactoring refactoring
90:42 okay commit sync the changes these changes will be in the signup
90:51 branch. Right now, let's refresh. We just had one commit. Now, we have two commits
90:58 with the latest changes. So, again, you can wait for a code suggestion on this one.
91:05 But in this case, I'll go ahead basically say merge the pull request.
91:10 Confirm. And this should be good to go. Now we will finally switch back to the master
91:19 which is this one. Okay. Now if you take a look at the master you don't really have the latest
91:25 changes. So under the o route this looks as it was in the previously right. So
91:32 we'll say sync this up. basically get the latest changes from GitHub.
91:37 Now we can see everything is right here as expected with the latest changes with
91:43 the latest commit. Okay. So I hope it was it was easy to understand what we
91:48 have done. I can pretty quickly show you again. We created a new branch put some
91:54 name created that and then we have committed then published the branch and
92:00 merge the pull request. Okay. So we'll be doing this couple of times in the upcoming sections. So I think you'll get
92:07 comfortable with it. And this is what you would be doing in real world implementation right in a company. You
92:13 have to create some pull requests and then you know send your commits. Okay.
92:20 So with that hopefully I'll see you in the next section. So in this section let's try to send a welcome email to our
92:28 users when they sign up. For the emails, we'll be using resend, which has a free
92:33 plan that we can use. So, under the pricing here, we can see without paying anything, we can send 3,000 emails per
92:40 month, which is pretty cool, right? So, here we can go ahead and sign in. This
92:45 is what I'll be doing. I'll use my Google account, but you can use your GitHub as well. And then they have
92:52 basically bunch of different uh bench bunch of different SDKs for any kind of
92:57 application, right? So here we'll go ahead use their NodeJS SDK
93:03 and it is pretty easy to get started with. So under the documentation copy this mpm install recent command open up
93:12 your terminal make sure you are under the back end and just say get this
93:18 specific version. So uh 6.0.2.
93:24 So install it under the back end. Then let's see what is the next step. I think
93:29 we need to get an API key. So once you are logged in, go under the API keys. If
93:35 you wanted to, you can put your own domain by the way, but in this case, I'll be using the recent domain, which
93:42 is onboarding recent.dev. Now, you can use this, but the disadvantage is that you can only send
93:50 an email to this account. Okay? So like your Google account. So whatever the
93:56 email you know whatever the email the admin is which is fine we are just testing it out
94:03 but in real world you would like to add your own domain. Okay. So, let's go ahead under the API keys. Let's say chat
94:12 pie app. I'll just say full access and let's
94:17 say add. Okay. Copy the API key. Let's say done.
94:23 We will go under the env. And we can say something like recent
94:29 API key. Okay. Paste this in. And then I'll also have the email prom
94:39 and then let's say email from name. So I'll put my name
94:48 and email from is the you know it's going to be this value.
94:53 So the email address onboarding atresend.dev that.
95:03 Okay, let's save and see the next step.
95:09 Basically, we need this kind of a function call with the email template.
95:14 So, we'll be using HTML to be able to send it. And here I have prepared a template, which is this one. And I'll
95:22 show you how you can copy and paste this. If you didn't like it, you can get your own version as well. So under the
95:29 source, I will have the emails folder and let's say email templates.js
95:37 and let's say email handlers.js. So go into the source code, find this
95:44 file and copy the content and paste this in. This is what I'll be doing. There's
95:49 like 50 lines of code. And here you can see this is just an HTML file with some images P tags.
95:59 Basically it is this end result. And here there is two different things that is dynamic. The username as well as the
96:08 application URL. Okay. So we are getting this as an argument the username where
96:16 we say hello whatever the username is and then the client URL it's going to be
96:22 under the link. So when they click to this link it should take us to our
96:27 application. So this is dynamic because we don't really know what the URL is
96:32 going to be. So here, this is my URL, but yours could be
96:40 something different, right? And I don't know why this is unavailable, but we can
96:45 fix this later in the video. Okay.
96:50 Now, let's go ahead save this file and we're going to build the email handlers now. And actually, just before this one,
96:58 let's go under the lireend.js file. And here we would like to import
97:05 resend just like in the documentation from resend. And then we can say export con
97:13 create a recent client. We'll say new resend. And then we would like to put
97:19 the resend API key. Now to be able to get this you need to import
97:25 and call the config method. So you can either do it in this way. Okay. So either like this or you would say
97:33 importv from env and call the config method. So
97:38 this and this is basically the same thing. Now there is even a better usage that
97:44 I'll show you. We will create av file here just I mean notv but just env.js
97:52 file and we're going to put our environment variables here. So we're going to get into it. So this is like
97:59 let's say to-do for now. Let's use it in this way. So we
98:04 got the recent client and I'll get an export con sender object
98:11 here. I'll say email and then the name. Okay. So we're going
98:17 to be using it. You will see what that does. So we got the recent client so that we can use this and send emails and
98:25 then the sender information. So in the email we can see who is the
98:31 sender. This is the name is probably your name and then your email. Okay. Now
98:37 we'll go under the email handlers just create a function. So here I'll say
98:43 export const send welcome email and this is going to take a couple of different
98:49 options. Let's say the email name and client URL.
98:58 Okay, so this email is to email like let's see what that means. I'll say
99:04 const grab the data as well as the error by calling recent client. Make sure to
99:12 import it and put the extension. So we will say emails uh send and this is
99:18 going to take an object. So here I'll say here's the from let's make this to
99:24 be dynamic and I'll say sender name and we're going to put these
99:31 carrots and I'll say sender email. Okay.
99:36 Then the two the receiver let's put the email. We can put the subject
99:42 which is going to be welcome to chatify right this is the subject you can put
99:48 anything and then the HTML is not going to be this obviously it is going to be create
99:57 welcome email template and this is under the templates here we can see it is the
100:02 function now this is a function so that we can pass our variables the arguments
100:09 okay Let's say name and client URL. Let's import it.
100:15 I think this is not the let's say emails
100:21 email templates.js. This is the correct path. Okay. So everything looks fine.
100:28 I'll say if we have an error here. I'll go ahead put some console logs and throw
100:34 some error. Okay. But in the else case that means it
100:40 is done successfully. We can just say welcome email send successfully and
100:45 console log the data. Okay. Now everything is done. All we have to do
100:50 just call this method when user signs up. So I'll go oath controller.js.
100:57 Here we have a to-do. Let's say try and catch. I'll say await sent welcome
101:04 email. And we need to pass the email which is the let's say saved user email.
101:13 Say saved user.name as well as the client URL. Again I think
101:20 to be able to use this we need to import the env
101:26 because we're using environment variables and in the catch we can put
101:31 like fail to send welcome email. So now I will delete this to-do save this file
101:37 and let's see if it's going to work or not. I'll try to sign up with this email
101:43 like um it should be this one right because we are using the onboarding
101:50 recent domain here. I'll say put my email for the name let's say my full
101:58 name. Okay, let's go ahead and just say send. We are not running the application
102:05 that's why it failed. Let's say mpm rundev.
102:11 Let's do it again. Okay, so looks like user has been created. I'll check out my inbox if I
102:19 get the email or not. All right, so here we can see it. It says zero means ago.
102:24 This is the full username. Everything is working. This is the sender the sender
102:29 email. It just works out as expected. And if you click to this one, it should
102:34 take you to the undefined. Um, it is not correct. Let's see why this did not
102:41 work. And by the way, we have welcome email sent successfully. This is the email ID. Okay, so everything works out
102:50 other than this client URL. Let's try to debug it. Okay, we have the
102:57 client URL under the env. So here since we are in development, our
103:03 client URL is our react application. I mean it's local host. So basically
103:09 client URL means front end URL. And in this case it is localhost 5173.
103:16 But in the production this is going to be something else, right? Whatever the
103:21 URL is, right? So in this case it would be this value but we're going to make it
103:27 dynamic in the upcoming sessions. So in development once again our front end URL
103:32 is localhost 5173. So if we save it everything should be
103:39 working out. If you try to sign up again um let's do it actually I will delete
103:45 this user so that we can sign up from scratch and get the email.
103:52 Okay. So, I'll delete this one from the database. Delete it. Let's send the sign
103:59 up request. And we should get a new email. Okay. So, let's say show.
104:08 And if we say open messenger, now it's going to open up our front end
104:13 application. Okay. So, that means this link is also working as expected. Now since we are not running the front end
104:20 we can see 404 which is completely fine. Uh we just make sure that the link is
104:25 working as expected. Let's pretty quickly go over what we have done. So we
104:30 have created our API key and put this in with some other fields to to see who is
104:37 sending the email and what is the full name and then we also put the front end URL to make the link work. Then under
104:45 the lip, we set up the resend, right? It's pretty easy like we just have one
104:51 object and another one for the sender. Then we have a template. You can change
104:57 this, make it however you want. This is what I provided. And then a function to
105:03 be able to send welcome email. And we are calling this once user signed up
105:08 successfully here under the try and catch block. So we wrap this with try
105:13 and catch. It's because if this fails, we don't really want to break our
105:18 application. If this fails, we'll just see console log. That's it. Right. Okay.
105:24 So that was the entire section. Just before we end it, let's try to set up our environment variables in a better
105:31 way. The problem that we have currently is every single time if you want to use
105:36 an environment variable like here we need to importv
105:42 and call the config method which is not really optimal instead of doing it in every single place we are just going to
105:49 do it here only once right so here let's say import
105:55 envig method then we can export an object like
106:01 env all all of our environment variables. So
106:07 I'll copy this but we're just going to put the keys here. I'll just comment this out so that
106:12 we can see it. So we'll have port which is coming from process.port
106:18 and then we'll do the same thing for  uri jwt secret. So as you can tell
106:25 I'll just get the node env. And I think
106:30 we can delete the fallback values because we are already going to we will always have them. And then here we can
106:37 put the client URL recent API key. Okay. So I think that's it.
106:45 Now if this doesn't make sense, I think it'll do in a second. Now in let's say recent.js.
106:54 So instead of doing process env we're going to delete this import and we will
106:60 just say env let's import it.
107:10 Oops. Let's say from lib. Oh actually just from the env.js file. Okay. Now we
107:19 don't really need to say process.v env import on every single file. We'll just
107:25 import the env object and get all of our environment variables. Right? Let's try
107:32 to do it in other files. I think we did it from the O controllers. Can delete
107:37 this. And here if you want to get the client URL, we'll just say env.client
107:46 URL. And we need to import it. Okay.
107:51 And let's see where else did we use it in the server.js I'll delete env.
108:03 So instead of doing it in this way I'll say env.port
108:09 also let's say envode env.
108:16 So currently we're just refactoring our code. Let's put it at the very end and
108:21 let's check if we have any other process env. So under the db.js
108:28 we can just say grab this from env
108:34 import it and here you can see we have all these fields.
108:41 So we have it here. Let's try to fix them. say envail from
108:50 and email from name. Finally, under the utils,
108:57 let's say env.
109:03 Okay. So, I think that's it. Hopefully, it it is not really confusing. Let me
109:08 close everything and walk you through it. Once again we have created the env
109:15 file and we are basically getting all of them from the env file and we are only
109:21 calling this MV config once right in any other files if we want to use an
109:28 environment variable we would just import this object just like this one and then we can say
109:35 you know env. EMV.NordV whatever that is. I hope that makes
109:41 sense. Everything is working as expected. So we can create a new branch.
109:48 Um here I'll say create a new one. Let's say welcome email
109:55 for the name. Let's say welcome email sent. Let's say
110:03 welcome email implemented. Let's publish the branch,
110:11 we'll go into the source code and create a pull request.
110:19 Okay, so just before we merge it, I'll wait for the suggestions from code
110:24 rabbit and once it is done, I'll just be right back. So here is a quick summary
110:29 by code rabbit. Here are the new features that we have introduced such as sending a personalized welcome email to
110:37 new users after they sign up and we have some refactoring such as C centralized
110:44 environment variable configuration right and you can take a look at the rest now
110:49 here it says this is transactional email which is correct and here I have a
110:54 screenshot so if you don't know already the transactional emails are the things like we send to one recipient at a time.
111:02 So they are like personalized emails, things like welcome emails, confirmation emails and password resets, right? This
111:11 is what we call the transactional emails. And then we have bulk emails
111:16 which are things like you send it to multiple recipients at once. And this is
111:21 great for newsletters. You send the same content to multiple users at once.
111:27 product announcements and then term and conditions updates. Okay, so just keep
111:32 that in mind as a developer you need to know these terms. Okay, transactional
111:39 and bulk streams or bulk emails and then we can scroll down see the sequence
111:45 diagram. Basically once user has been created we will send a response back and
111:51 in the background we will try to send an email without without blocking our code.
111:58 And then let's scroll to the bottom to see some suggestions here. It says um recent use node version
112:06 18 and above. That's fine. We already have 20 and above.
112:13 Um here it says instead of wrapping this with try and catch and awaiting you can
112:19 just do it in this way which is fine but it is not potential issue. This is just
112:24 suggestion. So I'm going to skip this. If you wanted to you can replace this code block with this one.
112:31 And then let's see again some suggestions here. It says if you do not have these environment variables just
112:39 throw some errors immediately. That's fine. like I would normally implement
112:44 them but for now I don't want to waste any time so I'll just skip that and then here it looks like in the email we say
112:52 something like welcome to messenger it says this should be chatify so this is
112:57 such a beautiful refactoring suggestion I think we should fix it maybe I'll do it in the upcoming sections basically
113:05 this should be our application name it is not messenger in this case okay we'll
113:11 scroll to the bottom Now, if you didn't use code rabbit, you would not be able to see this error, right? Unless your
113:17 users tell you. Okay, let's scroll. Okay, so we have a potential issue. It
113:24 says escape interpolated values and code href to prevent. Okay, so HTML
113:30 injection. So some users might put some malicious code here. It says maybe you
113:36 would like to make this URL to be safe first. I think that's perfectly valid.
113:41 This is what you should have in production. You can update this function with it. I don't want to waste any time.
113:47 So I'll just uh keep going. And then here again a suggestion. It
113:53 says you can put some errors like validations if any of these are missing.
113:59 That's fine. Same for this one. Okay. So these are all the suggestions that we
114:05 could have. And in this case, I'll just say merge the pull request.
114:11 Let's confirm it. We will go into our codebase
114:16 and then we can basically switch to the master. Now, we don't really have the latest
114:23 changes such as resend um you know, emails. But if we just say sync this up
114:28 with the GitHub repo, we should get everything in a second. Okay, so this is
114:34 what we have. the welcome email functionality is working correctly. So with that, I think
114:41 that's going to be it for this section and hopefully I'll see you in the next one. So now that we have built the sign
114:48 up functionality, let's go ahead and visit the O route and get started with the login and log out endpoints. Now
114:55 they are not going to be get requests, right? So let's make them to be post and let's try to delete the content.
115:03 Instead, we're going to give the login method as well as the log out. And
115:08 they're going to be coming from the oath controller. So, for now, let's say login and log out. Save. And let's go into
115:16 this file. Just shrink the sign up method. And we are going to create the
115:21 login as well as the log out.
115:30 So, I will duplicate this. Let's say it is going to be log out and let's first
115:35 get started with the login method. So if we take a look at the login page, user
115:40 is going to send us an email as well as a password so that they can sign in, right? So we'll go right here and we
115:47 will just grab those values. Let's say email and password. This would be coming
115:53 from request.body and we can have a try and catch block. So under the try first I'd like to check
115:60 if this user existed with this email or not. So I'll say con user say await user
116:07 find one and check it with this email. Since both of them are the same thing we can
116:13 shorten this. Now we'll say if there is not a user in this case we can say
116:18 something like res status. And by the way just make sure to return immediately
116:24 out of this function. Let's say 400 which means bad request and we'll say JSON let's say message. Now we don't
116:32 really want to say something like email is not found right or password is
116:37 incorrect. That's not a best practice. You should always say something like invalid credentials. So never tell them
116:45 the user which one is incorrect. Let's say credentials. How do we even
116:52 type this? I think like this. Okay, invalid credentials. Once again, never
116:58 tell the client which one is incorrect.
117:05 So, password or email. Don't say it. Just say something like invalid
117:10 credentials because there might be some malicious users. They can just check if this email existed or not. And if you
117:17 say something like email doesn't exist, you would be making them happy. Right now, let's check for the password. I'll
117:23 say const is password correct and we'll say await brypt. We'll be using the same
117:31 package. This time we would like to compare. So we'll say compare the password that user sends us to the one
117:40 that is in the database. So we'll say get this hashed password compare it with
117:45 this one and then we can say if password is not correct can say return again.
117:52 Basically the same thing. I'll copy this line. Um maybe just this part.
118:01 Okay. And just paste this in. But now if this is not the case, that means user is
118:06 actually authenticated. They send us the correct email and password. So we can say generate uh token and we're going to
118:13 pass the user ID as the first argument and then the response. Then finally we
118:19 can send a uh like response back to the client. In this case I am too lazy to
118:25 type this out which is four lines of code. So we're going to say 200 success
118:30 and here is the ID, full name, email and profile pick of the user. In the catch
118:35 let's say something like console.log log or maybe
118:41 error in this case let's say error in login controller
118:46 and just put the error okay let's say rest status of 500 JSON
118:54 this is going to be pretty classic internal server
119:02 error let's say okay so that's entire login functionality let's build the log
119:07 out and then test them out. So log out is a lot easier than what you think. Actually, this doesn't have to be an
119:13 async function and we will never use the request. So I can just even skip this
119:19 completely or put an underscore. Okay. So here basically we will we would
119:25 like to get rid of the cookies. So I'll say res.cookies.
119:31 We would like to get rid of this one because if you take a look at the utils
119:37 file here under the generate token method, we said we would like to set a
119:42 cookie that is called JWT. So if this was called something like token, right?
119:48 If you say token, then here you would say token as well. Just make sure that they are matching. Okay.
119:56 Now we would like to say new value is going to be nothing. Basically we clear this and let's try to kill it
120:03 immediately. We'll say maximum age is going to be zero. Okay. And then we can
120:08 finally say res status of 200 something like log out successfully.
120:20 Okay. So I think that's the entire thing. Let's try to open up the postman and test this out.
120:27 So we have couple of different users in the database. Okay. So how do I close this?
120:39 Okay. So we signed up with this account right now. Let's try to login here. I'll say API o login and make sure that you
120:48 are running your back end here. In this case I'm running successfully.
120:53 Now I don't really need to pass the full name. I'll just send the email and password. Let me send the wrong one.
121:01 Invalid credentials. Let's make the password correct. But email wrong again.
121:07 Invalid. So now if we put the correct one, we just logged in. This is the
121:12 result. Uh 200 status code and we have the cookie. Now let's try to log out.
121:21 You don't need to send anything for the body. Okay. So, let's just say send a
121:27 request. Resa cookies is not a function. I think I just have a typo. This should
121:33 be Razda cookie. Let's save and give it a go again.
121:39 Okay, now we are logged out. And if you take a look at the cookies, we don't really have anything, right? Okay. So, I
121:47 hope everything makes sense at this point. Let's try to log in one last time. We are just logged in and we can see the
121:53 cookies. So now um I think the login and log out functionality is also working as
122:00 expected. We can end this section right here. And in the next one we can add the update profile functionality.
122:08 Yep. So let's just get rid of these spaces. And now you might be asking why this is the post request and not
122:14 something like get because uh like this is the best practice because in logout
122:20 if you do it with get request it might be cached you might send it on refresh
122:25 things like that. So for that reason uh the logout functionality has to be post
122:32 method right like you can go with get but that doesn't make any sense. So this
122:37 is the best practice just keep that in mind. Um, here if you take a look at the code, you say, "Okay, we don't really do
122:43 anything other than clearing up the cookies." Yes, but you still have to go with the post method.
122:51 All right, so I think that's it for the entire section. Let's keep it short and sweet. I'll open up the status bar and
122:58 let's create a new branch and call it something like login and log out.
123:05 And we can commit our changes. Let's add to the staging area and let's say login
123:10 and log out functionality added commit. Publish the branch. Let's
123:17 go to the source code. That was the very last PR that we have
123:25 created. Now let's create another one.
123:35 Okay. So I'll just wait for the code rabbit to give me some reviews and at the same time we can take a look at our
123:41 deployment. So I have just realized like in the previous sections that the server
123:48 is crashed and this is something that I said we are going to fix it later in the video. Now maybe that's the time. So, I
123:55 just went to the deployment and under the deployment logs, I can see something like missing API key and you have some
124:03 errors and it says you don't have the recent API key. Now, you might say, hey,
124:08 how could this be even possible? In my recent file, I have my API key and it is
124:14 under thev file. So, it is right here. Why does the
124:20 deployment fails? Well, you have the environment variables, but it is local.
124:25 It is like it is existed locally on your laptop. So, you need to take these also
124:31 included under the environment variables, right? Currently, this is what you have for Savala. So, let's try
124:39 to actually get everything from here. Um, maybe I'll just copy everything,
124:46 right? Um, just go here. Just what should we say like add
124:52 environment variable. I'll paste everything. We can delete the port because we already have it. And what
124:59 else do we have? Let me just kill this. So we have node DNV and port, right?
125:05 This is equal to production and this is 3,000. Okay. So let's do it once again.
125:10 I'll add everything. We had the port and node env. So we can get rid of these and
125:17 just have everything as it is. Right now uh client URL is not going to be a local
125:22 host for now. We can leave it. That's fine. Um but actually actually this is
125:28 the client URL. This is the front end application that we have. Right? So I can copy this and paste it right here
125:36 and everything should be fine. Just make sure that you get rid of the very end slash. Right? Okay. So this is what you
125:43 should have in your case. Put your own domain. Grab it from here or from your
125:49 dashboard and just say save. Okay. Now I think it's going to deploy
125:57 it once again. Let's say deploy the changes.
126:03 This will take couple of minutes and then we should be good to go without any errors. Okay. Okay. So let's wait for
126:10 this to be completed as well as the code rabbit code review. All right. So the first thing that is completed was the
126:17 deployment. Here we can see it is running successfully without any errors and we can go ahead refresh this page.
126:24 Previously it was 500 but now we can get our react application. Right. So everything is working correctly in the
126:31 deployment part. So the only thing that we need to do is just adding our environment variables.
126:38 Once again at the client URL in the development it is equal to localhost
126:43 because this is our react application that is running in development but in production it is this application right
126:51 it is this URL this is our both front end URL and backend URL because we
126:57 deployed it under the same domain so for the client URL we had to put this one
127:03 okay just keep that in mind now let's wait for the reviews This will take
127:08 normally like 5 minutes. I think it should be done in a couple of minutes. All right. So, it is completed and let's
127:15 pretty quickly go over it. So, we have introduced login and logout endpoints where the logot clears the
127:21 authentication sessions and login returns the basic user details. And here are some more things that you can take a
127:28 look at like the refactoring. We have replaced placeholder um placeholder
127:33 routes with the actual post endpoints. so on and so forth. And then here is the
127:39 walk through of the files with the changes as well as the sequence diagram. So basically let's try to zoom in. User
127:47 is going to send a request with the email and password. Let's say they want
127:53 to log in and first we're going to check with their email and then compare the password with the brypt package. If
128:01 everything is done successfully, we will generate a token and set the oath cookie. What else? We'll say invalid
128:08 credentials for the mismatch password or if user is missing, right? And then we
128:14 have the log out functionality as well. So that's really cool. Let's scroll to
128:19 the bottom to see the suggestions. Here it says under the login method.
128:26 Just before you do anything else, maybe you can add this if check. Let's actually do it. Now I'll go under the
128:33 oath controller. Now here when you have some changes that you want to do before
128:40 merging, you can basically come into your codebase. Let's try to edit right here. Delete the
128:49 plus signs. Okay. So if if they are missing, if user
128:56 doesn't have email or password, we will say these fields are required.
129:02 We are going to have this. Let's see what else.
129:07 So when you are clearing out the quickies, it says put the options. This
129:12 is not a potential issue. So I'll just skip that. Okay. Just before we merge the pull request, we need to add a new
129:19 commit to this same branch. Right here, I'll go ahead and say something like
129:26 login refactoring.
129:32 Let's say sync the changes. And if you scroll to the top, now we had
129:38 only one commit. Let's refresh. Now we should have two commits, right? with the latest change which is this refactoring.
129:47 Okay, I'm not going to wait for the code rabbit this time because we already fixed our code. Now we'll just say merge
129:54 the pull request. Let's confirm and then we can go into the master.
130:06 Okay. So we would like to just get the latest changes.
130:13 Okay. So I think now our codebase is up to date. We have the login and log out endpoints just like what we have created
130:20 in this section. Okay. So I think that's it for this one. Maybe in the next section we can implement the update
130:28 profile functionality. So it's going to be under the oath controller.js file as
130:33 well. Okay. So I'll see you there. All right, so let's get started with the
130:38 update profile endpoint. So under the oath route.js, I will go ahead duplicate
130:44 this one and let's say it's going to be /update profile. Since it is related to
130:50 updation, we should say something like put method and then this is going to be
130:56 the update profile method. And let's try to grab this from the oath
131:01 controller.js. just go ahead and create it.
131:08 For now, we'll just leave it as an empty function. Okay, now let's think about it. If a
131:14 user wants to update their profile, they have to be authenticated and we can create a function right before this. We
131:22 will say this route is going to be protected. So say protect route and this
131:28 is a function that we are going to create. Basically if user is authenticated only then they can call
131:35 the next function which is to update their profile. If they are not authenticated this is going to throw
131:41 some errors and they cannot call this method. Okay. So I hope that makes sense. If not let's take a look at a
131:48 diagram. So this is the o workflow that we see previously. We already have built
131:54 this part. Now it is time to build the second part. Let's pretty quickly go over it. If user wants to sign up or log
132:02 in, they're going to send the request and if everything is done successfully,
132:07 we will generate a token and send it back to the client with the cookies.
132:12 Right? Okay. Now user is authenticated. They just logged in. for the next subsequent
132:19 requests. Things like if they want to send a message or update their profile,
132:25 fetch messages, anything. We are going to say, "Hey, if you're sending the
132:30 request, just send me the token with your request, right?" And this is going
132:35 to be done automatically when they send a request because we can get the token
132:40 from the cookies. I know that that could be a bit confusing, but it's actually
132:46 pretty easy. we will see basically if user wants to update their profile. Okay. So let's say they want to update
132:52 their profile they're going to send you a request and from the token from the
132:58 cookies we will see if user has a token. If yes we will see if it is valid or
133:03 not. If it is valid we will say okay you're authenticated you can update your profile. If not we'll say you're
133:10 unauthorized you cannot do it. So I hope that makes sense here. Even I have a
133:16 diagram. So user wants to update their profile pig. They would send a request
133:21 to our server and we need to check if user is authenticated or not. So before
133:26 this request we will check for that um authentication state with the protect
133:33 route middleware right and then here is the logic if user has a token right if
133:40 it is existed in the request. If not unauthorized, they cannot do anything. But if they
133:47 have it, let's check if it is valid or not. Right? Maybe they have the token but it is expired. So they can't do
133:54 anything. So if it is not valid again, we'll throw some errors. But if yes, if
133:59 it is valid, we'll say you can update your profile or send a message.
134:05 So I hope this makes sense. Let's see how we can implement it in our code. And I just said a word like middleware.
134:13 Right now this sounds pretty complicated but basically it is just a function that you
134:20 would run before sending back a response. So let me see let me show you
134:26 what I mean. So user sent you a request right before you sent a response back
134:32 you would do something in in the middle. That's why we call it middleware. And in this case, our middleware is going to be
134:39 the authentication check. Okay, I hope that makes sense. Let's see how we can
134:44 build it. I will go under the back end source create a folder called middleware
134:52 and then we'll say oath middleware.js file and we would like to basically
134:59 um create this function. So here I'll go ahead and say something like export
135:07 bones protect route.
135:15 And before we get into the function logic I would like to import a couple of different things. The JSON web token the
135:22 package the user um user.js file as well as our environment variables. Now first
135:29 we said we would like to check if token existed or not right. So say con token
135:35 we'll say request and here we need to get the request and response by the way
135:41 and we will also get something what we call the next function.
135:46 So I just told you that if this is done successfully we are going to call the next function. So this is how we can
135:53 call it with the next argument. So you're going to see this will make sense. Let's first get the token from
135:59 the request dot cookies and we call this as a JWT. Right? So once again let me
136:07 show you this. When we create a token we call it as JWT. So that's why this
136:12 should match with what you have here. Now this would be undefined unless you
136:18 do some configuration in server.js. So we have installed a package in the
136:24 beginning of this tutorial called cookie parser and I told you that we will be using this package to be able to parse
136:31 the cookies. So let's try to configure it here. I'll say app do use just call
136:37 the cookie parser all the method and let's try to import
136:42 it. I'll say import cookie parser from
136:48 cookie dash parser. Okay. Once you have it then you can actually use this. It is
136:54 going to work. Now let's say if user doesn't have a token you will say something like return res status. The
137:02 status of unauthorized is 401. And for the message we can say something like
137:11 uh let me just first say message unauthorized
137:17 no token provided. But now if user has the token, let's try to decode it. Let's
137:24 say const decode it. Um we'll say JWT.verify
137:29 and we need to use sorry we need to decode this token. We need to use the
137:35 our secret right the JWT secret because this is a secret that we created the
137:41 token with. Here we'll say if this is a falsy value we will say return I'll copy
137:49 this entire thing we'll say okay you're still on unauthorized you have the token but it
137:56 is invalid so say invalid
138:01 token okay but if like if the token is valid let's check for the user because
138:09 if you remember once again Under the token we put the user ID. So that's how
138:16 we can identify a token. So we'll say user await user dot bind by ID
138:26 and we will say decoded user id. So we decoded the token. We can get the user
138:32 ID and check for this user in our database. I'll say something like if
138:37 there is not a user we can say something like user not found. Let me paste this
138:44 in. Okay. But in the else case everything is done successfully. You can just call the next function. In this
138:51 case it's going to be update profile. Okay. And actually before you call the
138:57 next method you would like to add this user to the request. So you'll say
139:02 request do user is going to be equal to this user. So this is a custom field
139:08 that we just added into the request so that we can use this user in the next
139:13 functions. So I know that sounds complicated but we're going to see it in action. And here we would like to get
139:20 every single field of the user except the password. So I'll just say select
139:26 everything but not the password because we don't want to really send this back to the client. In the catch I can say
139:34 you know something like error in protect
139:40 route middleware and put the error then also we can put
139:48 res status of 500 internal server error. So this is the entire function that we
139:55 would need just to lines of code and this is going to be something that we'll be using a lot. Once again we check for
140:02 the token if it is existed or not if it is valid or not and then if user is like
140:08 if user is in our database or not by using the user ID and if this is the
140:13 case we can call the next function which means user is authenticated. And just before we do so, we are going to add
140:20 this user to the request and you're going to see it why in the incoming minutes. Okay, so that's the entire
140:27 thing. Let's try to import it. Import protect route
140:34 from let's go one up I believe under the middleware from this file.
140:41 Okay, now we can handle the actual method and this method will basically
140:47 allow the user to update their profile image and we would like to store the
140:52 images in some place. In this case, I'll be using Cloudinary. Let's try to pretty
140:58 quickly log in. I'll login with my GitHub account, sorry, my Google account. And then we're going to get
141:05 some credentials. Now just before we get the credentials we would like to install
141:10 the cloudary package um so that we can use their SDKs right so here I'll kill
141:17 the back end let's clear this up I'll say mpm install cloud cloudinary and for
141:25 a specific version is going to be 2.5.1 just make sure we are under the back end
141:32 okay let's install it and then rerun our application Oops. Say mpm rundev.
141:40 Now we will go under the lib and set this up just like resend. We'll say cloudinary.js
141:47 file. Here we'll basically put couple of different environment variables with a
141:52 function call. First let's get our environment variables. The first one is
141:57 the cloud name. I'll copy it.
142:03 Let's go under the back end and let's say something like cloudinary_cloud
142:09 [Music] name. Paste this in and duplicate this twice. We will have the API key as well
142:18 as the API secret.
142:24 Again, they have a free plan, so you don't really need to pay anything. Actually, I am also in the free plan. go
142:30 under the settings. We would like to create some API keys, right? I'll say
142:36 generate a new one. We got a confirmation code. So, this is my
142:41 confirmation code. I'll just copy it. Paste this in. Now, we can copy the API
142:48 key as well as the secret.
143:01 Okay, now we are using the environment variables under the env file. So here
143:07 I'll go ahead add them right here as well. So whenever you add a like whenever you add something to thev file,
143:14 you would like to add the keys to the env.js as well. Let's say it's going to
143:21 be kind of annoying, but let's duplicate this. We will have
143:26 called I think the API key and as well as the API secret. Let me just put them side
143:34 byside. Let's say API key.
143:41 Oops. What am I doing? So API key, API key and then API secret.
143:48 Let's do the same thing for this part. Okay. So once again we got the cloud
143:55 nary cloud name API key as well as the API secret. These are the things that we get from the env file. Now we'll go
144:03 under this cloudary.js file and actually set this up. This is going to be less
144:08 than 10 10 lines of code. So I just copy and paste it. We are importing cloudary
144:14 right. So they have this object called v2. But this doesn't make too much
144:19 sense. So I wanted to say something like rename this as cloudary
144:26 and then we get our environment variables right then we call the config method pass the cloud name API key and
144:33 API secret and then export this object we'll be using it in our controller file
144:40 okay so let's see how we can build it I'll have a try and catch block the
144:45 first thing I'd like to do is getting the profile pick from the request test.body and we can say something like
144:52 if there is no profile pick just return immediately say something like status of
144:59 400 JSON and let's say profile pick is required
145:09 right and then we can check for the user ID now how how can we check for the
145:14 currently authenticated user ID let's say con user
145:19 ID and if you remember we can just say request do user dot
145:25 ID now why this is the case why can we access to the request do user well it's
145:31 because under our oath middleware we said we are going to add the user under
145:37 the request and then call the next method that means under the next method
145:42 we can access to this which is our user right this is the currently authenticated user okay So I hope that
145:49 makes sense. Without that middleware, this would give you undefined or it would even break your code. Now we can
145:57 say something like await cloudary and we need to import it.
146:06 Let's say import cloudary from I think we need to go one
146:12 up under the ellip. Okay, just grab it from this file and
146:17 then we will say uploader call the upload method and we will just pass the
146:23 profile pick into it as the as the option. This is going to give us the
146:29 upload response. Then we can say you know update the
146:35 update the user's profile in the database because if you think about it we are uploading the image to cloud but
146:42 we also want to update our database. So this is exactly what we're going to do.
146:48 Let's say await user.find by ID and update. Let's put the user ID.
146:55 So this is the user that we would like to update. And here is the field that we want to update which is the profile
147:02 pick. Let's say upload response. It has this secure URL which is the URL that
147:09 the image has been stored. And then finally I'll add one more object.
147:15 I'll say new true. So this will basically return the updated user object. Let's say con updated user
147:26 save. Oops. Let's save. And finally just return sorry just uh send a response
147:34 back. So let's say status of 200 which means success. And for the JSON we can
147:40 just send the updated user. And in the catch I think I'm too lazy to type this
147:46 out. So I'll copy and paste let's say error in update profile. And here is the
147:52 uh message. Okay, so that's it for the update profile as well. That that's the
147:57 entire endpoint or the controller. Now we cannot really test this out, I think,
148:03 from the Postman because we are going to be uploading an image as a base 64. I
148:10 think we cannot do it in Postman. I have never tried it. But this is absolutely working. If not, if not in the upcoming
148:17 features, we would fix it. But I promise this is working as expected. I have tested out already. Okay. So that's the
148:24 entire thing. I think we can we can just basically commit our
148:31 changes. And just before we end this section, I have realized we are missing one more endpoint that's going to be
148:37 just one line of code. And this is to check if user is authenticated or not.
148:43 Now let's think about it. When do we want to use it? Let's say you are in the chat page, right? You're messaging with
148:50 a user and then accidentally you just refresh the page. You would like to
148:56 first check if user is authenticated. If user is authenticated, you will see this page. But if it is not, you would see
149:04 one of these pages, right? You would see the oath page. So we need to create a method to check if user is
149:11 authenticated. And whenever they visit our application, let's visit it pretty
149:16 quickly. Whenever they visit the application, the first thing we will do in the background
149:22 is to check if user is authenticated or not. So I hope that makes sense. This is
149:27 going to be a get request since we are just checking and I'll say check. This is the o check and first we'll say
149:35 protect this route. This is how we can check for the authorization, right? the authentication and then if user is
149:43 authenticated successfully we can say call this
149:48 controller let's say res status 200 and for the JSON we will just send
149:56 the user back to the client okay now let's try to test this out I will try to
150:04 log in so we are logged in let's create a get request API IO check. We don't
150:12 really need to send anything. Let's say send. Okay, user is authenticated,
150:17 right? Let's try to log out and again call the get method. It says
150:24 like unauthorized. You don't have the token. So, you are not logged in.
150:30 Okay. So, that's the method that we're going to be using in the front end. So, with that, let's try to commit our
150:37 changes. I'll close everything. and toggle the status bar. Let's create
150:43 a new branch and you can call this as update profile
150:51 stage the changes.
150:58 Okay, I'll commit. This is my message. Publish the branch and let's try to create a pull request.
151:12 Okay, now I'll just wait for the code rabbit code review. So here are the new
151:18 features that we have introduced in this section. You can take a look at the files with their summary. You can pause
151:25 the video if you really want to read it. There is a huge sequence diagram at this point. So these are the things that we
151:32 have explained. Basically at the end of the day we are just checking for the token right within the cookies if user
151:39 is authorized or unauthorized. Again you can take a look at it if you
151:44 really wanted to. In this case I'll just skip so that we don't really waste too much time. Now let's take a look at the
151:50 code suggestions that we have. Um here it says potential issue where the size
151:57 should be at maximum 5 mgabytes. So this looks a little bit complicated. We'll do
152:02 it in a better way. Basically, at the moment, under the server.js file, let's
152:08 kill those. So, this doesn't allow you to pass anything larger than 50 kilobytes,
152:16 right? But what we'll be doing is basically say limit is going to be 5
152:21 mgabytes. So, this is something that we can do later in the video. I'd like to show you the error in the front end. we
152:29 can get something like payload too large error. Okay. And we can fix this by
152:35 adding the limit. So this is something that I will have later in the video. For
152:40 that reason, I'll skip this optimization. Um here maybe one thing that we could do
152:48 is just add this select at the very end here in the update say oath controller.
152:58 Okay, here maybe we could just say select dash password. You can do it for now. I don't want to add one more
153:04 commit. Let's scroll to the bottom. Here it says you can fast fail if if you
153:11 don't have these environment variables, which is fine. And then another potential issue. Well,
153:19 it's not really that much of a issue here. It says you can check for the errors explicitly.
153:26 Again, you can definitely do it. I'm going to skip this so that we don't really waste too much time. Okay. So,
153:33 with that, I'll say merge the pull request, confirm, and we're going to get the latest changes in the master branch.
153:43 Okay, let's go here, close everything, and sync this up.
153:50 Okay, so we have everything up to date. We got
153:56 our middleware declinary everything is coming from our source code in GitHub. Okay. So with that
154:03 that's going to be it for this section. Hopefully I'll see you in the next one. Now in this section we are going to
154:09 learn about a new concept which is called as right limiting. This is something that most beginners doesn't
154:16 really know but hopefully we are going to learn it in a couple of minutes. So what is rate limiting in the first
154:22 place? It is a way to control how often someone can do something on a website or
154:28 in an application like how many times they can refresh a page, make a request
154:34 to an API or try to login. So we are going to put some limits. Let's say only
154:40 100 requests per user every 2 minutes. Now you might be asking what does that
154:46 mean? I think this is pretty clear. But let's say like you just sent infinite amount of requests, right? You just
154:53 don't stop in a minute. You sent like 200 requests, right? We don't really
154:59 want this to happen. We would like to put some limits otherwise everyone can just send unlimited amount of requests,
155:07 right? We're just going to break our server at the end. So uh just in front
155:12 of our API we're going to put a rate limiter where the requests will be
155:17 filtered out depending on if we should accept them or if we should reject them.
155:22 Right? Okay. So rate limiting helps with preventing abuse and protecting servers
155:29 from getting overwhelmed. And for the status code it is 429
155:34 which means too many requests. So we are going to see this in action. Um, now
155:41 let's try to implement the rate limiting. And to be able to implement it, we'll be using a platform called
155:47 Arjhat, which has bot detection, rate limiting, email validation, attack
155:52 protection, and a lot more. So, they have all kinds of SDKs. We'll be using
155:57 the Express SDK, right? So, first we'd like to go ahead and log in. This is
156:02 what I'll be doing. I'll just log in with my Google account. You can use the GitHub as well.
156:09 Okay, so now we are in we would like to get our API key, right? So here let's
156:14 actually copy it and then we're going to put it under the back end under the env
156:21 file. So I'll just paste this in and for the key I'll say arcjet_key
156:28 and then we also want to have arjet environment. So I'll say arjet env let's
156:35 say development. Now in production we don't really need to add this but since
156:40 we are in development they say you should add this key. Okay. Now let's go
156:45 ahead select the NodeJS and express SDK. Let's say continue with it. If you
156:52 wanted to you can read it completely which is like maybe 3 minutes but I'll
156:57 just go ahead and implement it immediately. So here first we would like to install
157:02 express which is something that we have done. So we can um just get the archet.
157:07 So we'll get arjet node and inspect. I'll copy it. Open up my terminal. Let's
157:14 kill the back end and I'll paste this in. But we would like to put some
157:19 versions. So just before I install it, I'll say archet node. Um this is going
157:25 to be 1.0.0- [Music] beta.10.
157:32 So let's do the same thing for this one.
157:39 Okay. So go ahead and install it. Now since we have added some environment variables under the env file, we would
157:47 like to add them under the env.
157:54 So always get the keys which is arched key and archet environment. Now this is
158:01 going to be coming from process.env. env. Okay, so we have the keys. Now we can
158:08 set up arcjet. In the example, they are doing it in a single file so that it is
158:14 easy to understand. But what I'll be doing is to get this configuration.
158:19 Okay, I'll just copy it and I'm going to implement it under a specific file. So
158:25 under the lib, I'll say arcjet.js
158:30 and paste this in. Okay, so we have our environment variable, but we would like to import it from env.
158:41 And make sure to put JS at the end. Okay. And then we would like to get some
158:47 more imports. So I'll copy everything here. Um, even this one, I believe. No, just
158:55 this one.
159:00 Okay, so we got the arch chat, the shield, the techbot, and token bucket.
159:06 So this is an algorithm for rate limiting, but I'd like to use the sliding window instead. So you can use
159:13 any of them. Okay, either this one or this one, which is what I'll be using in this video. Now let's see what is going
159:20 on in this file. So we are having this arcjet method which is taking an object
159:26 with couple of different key value pairs. So first they say get your key which is something that we have done. So
159:32 I'll delete this comment and then we have some rules to make it work properly which is an array of different function
159:39 calls right. So here uh we are using shields which protects our application
159:44 from common attacks. To give an example SQL injection is one of them and the
159:50 mode is live here. Okay. And then we have the bot detection. So this is how
159:55 we can do it. We'll just say detect bot pass the object mode is live which is going to block the requests. If you use
160:03 dry run. So you have another option like dry run which is going to only log the
160:09 requests but we want to block them immediately. So I'll go with live. Now
160:14 you can block all kinds of requests but you can ignore some of them. Right? So
160:20 here we say do not um do not block the search engine requests because if you
160:26 think about it there are also some bots right but we don't really want to uh we
160:32 don't really want to block them and you can see the entire list under this URL so I'll just leave it here as it is then
160:39 they are using the token bucket as the rate limiting algorithm but I'm going to
160:44 delete this instead I'll use a sliding window okay we're going to call this
160:49 with an object let's say mode is going to be live and then for the maximum like
160:56 the maximum requests I'll say 100 and the interval let's say it'll be 60
161:03 seconds which is like 1 minute right okay so basically we are allowing 100
161:09 requests per minute and at the very end we'll just say export default the archet
161:17 uh the object right we'll be using it in a couple of minutes. Okay, so I think that's pretty easy to understand. We are
161:23 getting our key with some rules like shield the techbot and our rate limiting
161:29 algorithm. Now we'll go ahead and create a middleware. Let's say under the
161:35 middleware file or the folder I'll say arcjet.m middleware.js.
161:42 Okay. So we're going to write a function so that we can um you know we can call this in our routes. If that sounds
161:49 confusing you're going to see it in a second. Please for now just follow along with me. So first I'll get the arcjet
161:56 import from let's go one up under the li from this file arcad.js.
162:03 Okay just go ahead and import it. Then I'd like to get one more import. So here
162:09 we can see let me zoom in. we have something like is spoofed bot. Now I'll
162:15 explain what that means for now. Just import it. Then I'll create a function.
162:21 Let's say const arcjet protection.
162:26 Okay. So let's say this is going to be an async function. We are going to take the
162:32 request response and the next method. So just like a controller but this time it
162:37 is a middleware. Okay. So here let's say we'll have try and catch block under the
162:43 catch you can do something like arjad protection error and put the error
162:50 right and then just call the next method whatever that is and then in the try we
162:55 can get the decision. So we're going to have a decision either that we want to
163:00 you know deny either that we want to block or accept. So say await archetect
163:08 and we're going to pass the request. So depending on the request, it's going to
163:13 get us a decision and then I will have an if statement. So I'll basically say
163:19 if decision do is denied. Let's call the method. So here we will run something
163:27 else. Let's say actually else if we will do something else. if decision reason is
163:35 bot. Okay, so go ahead run this as well and in the else case we'll do something
163:41 like something different. Now in the if I'll basically say if decision dot
163:48 reason is right limit let's call this method here I'll say something like
163:55 return out of this function res status if you remember I said the status code
164:02 was 429 in these diagrams so we are going to be using it 429 and let's say something
164:10 like a JSON we can put a message like rate limit exceeded
164:18 and say please try again later. Okay, so that's going to be for this uh if
164:24 statement. And then in the else if since we are checking for the bot detection, we'll say something like bot access
164:31 denied. And then finally in the else case, I'll put some more general message. Here I'll say 403, which means
164:39 forbidden, and access denied by security policy. Now I just realized this if
164:45 should be the parent. So that means I'm going to cut this curly braces and paste
164:52 it at the very bottom. Okay. Now this is the parent if which says if it is denied check for these
164:59 reasons. Okay. Now finally I'd like to check for spoofed bots. And you might be asking
165:06 what is a spoofed bot in the first place. Basically it is the type of bot
165:11 that acts like a human. So they are bots but they pretend to be not a bot. So
165:17 it's really hard to detect them but thankfully Arjet will do it for us. So I
165:22 just grabbed this from the documentation. Basically if decision includes some bots we will throw this
165:29 error. But if this is not a spoofed bot and if there is nothing denied we can
165:34 finally just call the next method. Okay. So let's actually test this out. I'll go
165:40 ahead open up the oath route. Now just before the login we can say
165:47 something like archad protection. But if we sent the request from postman I
165:53 believe it's going to think postman as a bot. So let's send the request. Okay. So
166:00 as I said postman is uh detected as a bot. Let's try to test this out from the
166:07 browser. Here I will have a get request
166:13 let's say test and we can have the arcad protection and
166:18 then you know let's say something like test
166:24 route. Okay now just before we test this out
166:30 I'll visit the arcad file and for the maximum I'll say five requests per
166:37 minute. so that we can test this out quickly. Okay, let's say localhost 3000
166:46 API oath test. So test route is working. This is the first request. Second,
166:53 third, fourth, fifth. But now it should say something like rate limiting. Okay,
166:60 rate limited. That means in 1 minute we can only send five requests. more than
167:06 that is going to get you know get blocked here we can see okay so that means everything is working rate
167:13 limiting works but detection works um we don't really have any issues so I can
167:19 delete this route but now we would like to implement this on sign up as well
167:24 let's say archet protection same for the logout
167:30 same for this one now as you can tell it is kind of annoying right every single
167:35 time we need to add it one by one. So what we can do instead of adding them
167:41 separately I'll just delete all of them and here I'll say router do use archet
167:49 protection. So first this is going to run if this calls the next method then
167:54 it's going to call the related function. So I hope that makes sense. If
167:60 everything is done successfully, we're going to call the next method, which is going to be one of these. Okay, so I
168:08 believe that's it for this entire section. Just before we end it, I'd like to visit archet and bring this back to
168:14 the previous state. So this is more like a realistic goal, right? 100 requests
168:20 per minute rather than five in a minute. This is just for the testing purposes
168:26 that we have done. Okay, so let me pretty quickly walk you through it what we have done. We set up the archet with
168:34 these environment variables as well as under the env file and then we created
168:39 the arcjet.js file to put our algorithm you know the techbot as well as the
168:45 shield methods as well as our key. Okay. Then we created a middleware
168:52 which is to check for the decision if it is denied or not. If it is a spoofed bot
168:57 or not. If it is not we're going to call the next method. Okay. Then finally
169:03 under the oath routes we are calling it. Okay. So that's it. I hope it was not
169:09 really confusing. The rate limiting is something that you almost always want to implement in any kind of application. So
169:17 just keep that in mind. Now I'll say command shiftp. Toggle the status bar.
169:22 Let's open up a new branch. Let's create a new one. I'll say rate limiting.
169:30 Stage our changes and add a commit. Let's say rate limiting
169:39 implemented. Okay, I'll commit this. Publish the branch. Let's go ahead and create the
169:44 pull request. So, under the source code
169:50 and I just got a bit sick. My voice could be a bit low compared to the
169:55 previous sections. I hope it is not really annoying. Okay, so I'll create the pull request and
170:02 let's wait for the suggestions that will be coming from Codrabit. And once again,
170:07 if you would like to get these kind of suggestions, you can find the link in the description. Sign up to code rabbit,
170:13 get a free trial and connect your repositories. This is what I have done. That's why I can get all these
170:20 suggestions in my pull requests. All right. So here are the new features that we have introduced to our codebase by
170:27 updating all these files and here is a quick sequence diagram to you know to
170:34 show you when it's going to get right limited when it's going to get bought blocked things like that. You can take a
170:41 look at it if you really wanted to. I'd like to pretty quickly skip to the code
170:47 suggestions. Now, since we got everything from the ARJet documentation, I think our code is mostly correct. So,
170:55 here it has some optimizations to determine the mode, but we can just go
171:00 with the live mode all the time in our codebase. So, I think I'm just going to
171:06 skip everything um and just merge the pull request. Again, if you wanted to pause the video,
171:12 take a look at these suggestions and update your code um depending on this.
171:19 All right, so I'll say confirm the merge
171:24 and then let's get into the master branch.
171:30 And then we're just going to sync this up.
171:37 Okay. So now everything is up to date. This is the code that we have written in this section. So with that hopefully
171:44 I'll see you in the next section. All right. So in this section let's try to get into the messages. So the first
171:51 thing that we would like to do before creating routes or controllers is to create a message.js
171:58 model. Right? So I'll say message.js. Now here every single message in our
172:03 database will have couple of different fields like who is the sender, who is the receiver, if message has a text or
172:11 an image. So for that reason, I'd like to just copy and paste it to not waste any time and I'll walk you through it.
172:18 If you want to copy and paste this, just go into the source code under the models, find this file and copy paste
172:26 the content. Okay, so we are importing the mongus. Then we are creating a
172:31 schema right. We pass an object which says every single message will have a
172:37 sender ID and this is a user ID right. So it is required and if you want to
172:42 make a different model as ID you have to pass the reference. Okay. So this
172:48 basically says the sender ID is going to be an ID coming from the user model. I
172:55 hope that makes sense. Same for the receiver because sender and receiver are
173:00 going to be the users in our database. Then the like each message could have a
173:06 text or an image. Right? So let's take a look at it here. This is an example.
173:12 Message could either be a text or just an image or both of them at the same time. So if this had a caption, you
173:20 would see it right here. In this example, we cannot see it, but you can have both of them at the same time. And
173:27 for the created at and updated at fields, we're going to add the timestamps to be equal to true. Okay.
173:34 Finally, we create the model and export it. So, nothing complicated in this file. Just go ahead create it. Um, and
173:42 then we can get into the message routes. So, first we are going to visit the server.js file. We already have the
173:50 message routes. I thought we didn't, but looks like we have. I'll go ahead open this up. Okay, so instead of this test
173:57 endpoint, we can actually create the correct ones. So, let's delete this one
174:02 or maybe just leave it as it is. The first one I'd like to create is to get
174:08 all the contacts. So, here under the contacts tab, you can get every single user in your database.
174:16 And then under the chats, you're going to get only the chats that you have with
174:21 other people. Right? So just like this. Let's see how we can create them. This
174:27 is going to be slash contacts. And then we are going to run a method called get
174:32 all contacts. Okay. Let's duplicate it. This is going to get all the chats.
174:39 Again a get request. Let's say get chat partners.
174:47 Then we're going to have one more get request which is to get the messages. So
174:53 here I'll say slash colon id. You're going to see what that is. Let's say get
174:60 messages and that's it. You know actually let's say something like get messages by user
175:07 ID. So we are going to pass a user ID to this endpoint and it's going to give us
175:13 all the messages between us and this user. So to give you an example, let's
175:18 say you click to this chat. You are going to pass this user ID to the endpoint and it's going to give you all
175:25 the messages between you and this user. Okay, so I hope that makes sense.
175:30 Otherwise, how can you get the messages between you and this user or this one or
175:36 this one? Right? you need to pass the id of them specifically to get the
175:41 messages. This is what we're doing. And this could be anything. That's why we put colon. So
175:48 it is a dynamic value. And then finally, this is going to be a post request. Let
175:54 me delete the controller where we want to send a message. Right? So here this
175:59 is going to be send and then the user that we want to send the message to. So we're going to put the ID and let's say
176:06 send message. Okay. So these are all the endpoints that we are going to have for
176:12 now. I'm going to um I'm just going to comment all of these. Okay. I'll just
176:18 have the contacts. So we're going to build them one by one. Let's go into the message controller file. I think we
176:25 don't have it. Let's create it.
176:31 Okay. So the first one that we are going to create is this function. Let's say export const get all contacts. Let's say
176:39 this could be an async method. And let's import the message model
176:46 message from okay from this file. And just make sure
176:52 to put the extension at the very end. And also just make sure to import the
176:57 user model. I'll duplicate this. Let's say get this from the user.js file. Now,
177:04 how can we get all the contacts? Well, let's create a try and catch block first. In the try, let's first get the
177:11 const logged in user ID which is going to be coming from request user ID or you
177:19 can also put underscore ID. Both of them should work. Now, we would like to get all the users in the database but not
177:27 ourselves, right? We don't really want to see our account here under the contacts. So that's why we are going to
177:34 filter this out here. I'll say closed filtered users and here I'll say await
177:43 user.find and I think AI suggests us correctly. So we would like to basically fetch every
177:50 single user but the one that is not equal to to the logged in user. So it
177:56 says find every single user but extract this ID. Okay, I hope that makes sense.
178:02 And we can just say select the minus password.
178:08 So we don't really want to send the password back to the client. And let's say res status 200. And here is the
178:16 filtered users. Under the catch, I'll say something like console log error in
178:22 get all contacts and status of 500. So
178:27 let's try to save this file and test it out immediately here under the API
178:32 messages and from oops let's say from contacts.
178:38 This is going to be a get request. Okay, I think we are not running the
178:43 back end. Is this correct? Get all contexts is not defined. Let's see here.
178:48 We need to import it with thejs at the end. And take a look at the terminal. No
178:56 errors. Okay, let's test it out. It says server error. Let's see once
179:02 again. Get all contacts cannot read. Okay. So
179:09 why this is the case? Can you find the issue? Here we are calling get all
179:15 contexts and from here we would like to get the user object which is undefined
179:21 and from undefined we are trying to get something which breaks our application. Now to be able to access to the request
179:28 do user we need to make this a protected route right this is something that we
179:33 have talked about in the past. Now if user is authenticated the user object
179:38 will be under the request because in this method we add it. Okay. Now let's
179:44 test it out. Okay. Here we go. It fetches all the
179:50 users in the database other than ourselves. So currently I am logged in
179:55 as this user. Okay. And it fetches all
180:01 the other users than us. If you don't add this filter,
180:07 so if you remove this, it's going to get you three users. So currently it is two.
180:13 But now we have this user as well. Okay. But I'm just going to put this back so that I don't really fetch my own
180:21 profile. Okay. So let's move on with the next function here. It's going to be the get
180:28 chat partners. Now this is a bit more complicated. I mean it is kind of long. So for that reason I'm going to skip
180:34 this and get into this one. And I think at the very end we are going to build this um build this function this
180:42 controller. Okay for now let's copy this name and create it right here. Export
180:48 con get messages by user ID. Let's say async request and response create method
180:56 and let's import it. Okay. Now let's say try and catch block.
181:03 Now in this controller I would like to find the messages between me and a user.
181:09 So let's say first let me grab my ID which is the request do user
181:16 ID. This is the authenticated user ID. And then we can get the ID from the
181:23 request.prams. So here we just say id because this is
181:29 what we said here. If you set idx then you would get it as idx right here this
181:36 is the user id and it's going to work in this way. Let's say user will send a
181:41 request to / ai/ messages and it's going to pass let's say ID of this user. So
181:49 basically it says give me all the messages between me and this user. So
181:54 we're going to grab this from the URL from prams and let's make it a little bit more readable. I'll say user to chat
182:03 ID. Okay. Now I'll try to find all the messages between between us. I'll say
182:10 await message.find open up an object. And here I'll say the
182:17 or operator. And you're going to see why in a second. Here I'll put one object.
182:23 I'll say sender ID is equal to my ID and
182:28 receiver ID is equal to user to chat ID
182:33 and just duplicate it. This time sender ID is going to be user to chat ID.
182:40 Receiver ID is going to be my ID. Now you might be asking what does that mean? So this basically says find all the
182:47 messages between me and this user. And there is two cases for this. So either I
182:54 am the sender or I am the receiver. Now let me give you an example. Let's say me
182:59 and you are messaging, right? So there are two different possibilities. Either
183:06 I sent you the message, right? Or you sent me the message.
183:13 So in this case if I sent you the message, sender is me, right? And
183:19 receiver is you. But if this is the case, you are the sender and I am the receiver. So I hope that makes sense for
183:26 the very first time. If you see something like this, it might look complicated. So that's why I wanted to
183:32 give this example. Okay. So that's going to get all the messages between these
183:37 users and we can say resa status of 200 JSON and send the messages back to the
183:44 client. And then okay, this should be messages. And then here I'll just put the classic
183:51 console log as well as the internal error. Now that we are done with this
183:56 method as well, we can get started with the send message controller. So let's try to copy the name create it right
184:04 here async request and response and I'll
184:10 basically import it. Okay. And once again, you would like to make this to be protected. Only
184:17 authenticated users can fetch the messages. And same for the send message.
184:25 If you're not authenticated, you shouldn't be able to send a message. Right here, I'll have a try and catch
184:31 block. Now, since we already understand how most of the things work, I can basically speed up the process a bit by
184:38 copying and pasting. So, from the users um like from the request. body we are
184:44 going to get the text and the image. Um here I would like to get the user ID
184:50 again it is coming from from URL right this is the receiver ID and then I will
184:57 get the sender ID which is us right the authenticated user now again if user
185:03 wants to send a message there are two different options which is it could be either an image or just a text so if
185:11 there is an image we'd like to save it to cloudary right so let's check for it
185:16 first I will create a variable let's say image URL we do it with let because we
185:22 are going to reassign it and then here I'd like to give you the if statement
185:27 I'll say if user wants to send an image we like we would like to upload it to
185:32 cloudary and then get the secure URL um and assign it to the image URL right
185:39 let's import the cloudary from this file and then we are just going to create the new message. So here
185:47 I'll say new message. Here is the sender, the receiver text as well as the image URL. Um finally we can say await
185:56 new message dots save right save it to the database and res status
186:03 of 201 which means something created successfully. And here is the new
186:09 message. Okay. So here I'd like to have a to-do. So later in the video, we would like to
186:16 implement real-time functionality. So we don't really want to just save the message to the database, but in real
186:22 time, we would like to send this to the other user. Right? So I'll say send message in real time
186:31 if user is online. But this is a to-do that we are going to implement with
186:37 scikit.io later in the video. Okay. In the catch, let's put the console log as
186:44 well as the status code and we can immediately test it out.
186:51 Okay, just before we do it, I'd like to see my terminal if I have any errors. Looks like I don't.
186:57 So again, I am logged in as my own account. I'd like to send a message to
187:03 John. Okay. So copy their ID, paste it to here and say something like post
187:09 request API messages slash send and then
187:14 the user ID. Now for the body we can say text. For now just ignore the image.
187:21 Okay, for the text I'll say, "Hey John, how's it going?"
187:29 Okay, I'll send the request. Looks like a message has been created. Now let's
187:34 take a look at the database.
187:41 So under the messages looks like we have a message that says hey John how is it
187:47 going? This is the sender and this is the receiver. And let's try to call this
187:53 endpoint to get the messages. Right? So here I'll go ahead and say messages not
188:01 send but just a get request messages between me and this user.
188:08 Okay, so that's the message that we have. Let's try to send another one
188:13 here. I'll say another message
188:21 and let's try to fetch them again. Okay, so here we can see now we have two
188:27 different messages. That means everything is working as expected. Now finally we can add this endpoint and
188:34 make sure that you have them in the same order that I have because if you put this one above this, this is not going
188:42 to work because this is dynamic, right? It can match with this one. So you you
188:47 want to make sure that it's in the same order that I have. And then let's make this to be protected.
188:54 Then we're going to copy this, save this file, and create that method,
189:01 get the chat partners.
189:07 Okay, so this function is going to be I think a bit complex if you are using it for the first time,
189:14 but I'll try I'll try my best to explain it. So we would like to fetch only the
189:20 chats that we have. So in the database under the context I mean under the contacts we have let's say 100 different
189:28 users but let's say we have only messages with these two users right how
189:34 can we fetch only these and display them under the chats. So basically we're
189:40 going to say in the database we would like to find all the messages where
189:45 either we are the sender right let's say sender
189:51 is us or oops
189:56 or the receiver receiver is us okay so we are going to
190:02 find all the messages that is related to us right and then from those messages we
190:07 are going to extract ract the users. So let's see how we can implement it in the code here. First I'll have the try and
190:15 catch block under the try. Let's get the logged in user ID
190:23 from request do user ID and then I'll just put a comment.
190:29 Let's say find all the messages. say find all the messages where the
190:37 logged in user is either sender or receiver
190:44 and I can just copy and paste it. This is something that we have done. So find all the messages and here is our
190:51 filter right but now this is not enough because we just fetch the messages but
190:57 instead we would like to find the users right so I'll say cost chat partner ids
191:05 and here I'll say something like let me give a bit space I'll say from the messages let's say do a map and let's
191:13 grab every single message and run this case so here I'll say if message
191:20 sender ID is equal to logged in user ID. If this is the case,
191:28 I would like to get the receiver ID.
191:33 But in the else case, I would like to get the sender ID.
191:38 So this should be message receiver ID and message dot sender ID.
191:46 Now this looks a little bit complicated. Let me try to explain. So we fetch all the messages. Now from every single
191:52 message we would like to say if the sender is me, I would like to get the
191:58 receiver because I I'd like to fetch the other user, not me. I'm going to get the
192:03 other user profile and display it here. So for that reason, we will just try to get the other user's ID. I hope that
192:11 makes sense. And then uh you know just to make this work properly we can say to string because it might be an object. So
192:20 I'll copy this paste it right here as well. Let's do here and here. Okay. So
192:26 we just take the ids and convert it to be a string. Now I would like to remove
192:32 the duplicates. So I'm going to wrap this with a new set.
192:37 Let's say new set. And then I would like to make this to be an array here. Let's
192:43 go ahead wrap this with an array. And I would like to spread this one, two, three. And I think this should be right
192:51 here. Okay. So there could be some duplicates.
192:57 For that reason, we said this is going to be a set and then this is going to be an array. So we can just spread this.
193:04 Okay. I hope that makes sense. Now finally we can say post con chat
193:10 partners. So we got their ids. Now we can fetch
193:16 them. I'll say user.find. We're going to pass the underscore id
193:22 field. Let's say if it is in
193:28 okay sorry I just made a mistake. Let's delete this part. This is going to be an object as well. Let's say if it is n
193:35 under the chat partner ids we can just basically fetch all these users and then
193:42 I'll say select minus password again let's say return sorry res status
193:51 of 200 JSON and then the chat partners okay so
193:58 this is going to fetch all the partners that we have and then handle the catch case as well. So let's save and give it
194:05 a go. We are going to send a request to / chats. Let's import it.
194:12 So get request to API messages and chats.
194:20 We got the profile of John because we sent the messages to this user only. Now
194:25 let's try to send a message to someone else like let's say context I mean
194:32 contacts um get the Jane's ID and send a message to Jane I'll pass the Jane ID
194:40 and let's say hey Jane send the message now from the chats
194:48 right from the chat partners we should get the John as well as Jane so that
194:54 means this is also working correctly. Now let's go here and just try to
194:59 optimize our code a bit. So here you can see we are duplicating this protect route method couple of times. So instead
195:07 I'm going to delete all of them. And if I want to implement this to every single one of these methods I can just say
195:14 router use and call the protect route middleware. Right? First this is going
195:20 to run and then this. Now I also want to run the rate limiter arcad method.
195:26 Right? So here I'll say arcad protection. First I would like to run this one. If it is done successfully we
195:33 are going to run protect route. And if this is run successfully then we can call the specific method. I hope that
195:41 makes sense. Now this makes our code a lot more cleaner instead of having duplicate methods. And here I'll just
195:48 add a comment. Basically, it says that these middleares would run in order,
195:53 right? So, first the request would get right limited and then authenticated. And this is actually more efficient
196:00 since authenticated requests get blocked by right limiting before hitting before
196:05 hitting the oath middleware. Okay, I'm really sick. I can't even talk properly.
196:11 Hopefully, it's not really annoying. Um, with that, I think that's the entire section, right? We don't really have any
196:17 errors. We have implemented the messages. Although we have a to-do for the send message, we are going to make
196:24 this to work in real time. Currently, it doesn't work. We just save it to the database. Okay. So, let's kill
196:32 everything and toggle the status bar. I'll create a new branch. Let's say
196:39 message routes.
196:49 Okay, I'll commit, publish the branch, and let's try to create a pull request.
197:06 And as always, I'll just wait for the code suggestions before we end the section. So here are all the features
197:13 that we have introduced in this section. Basically this these are the things that
197:18 we have under the message routes. We can have direct messaging with the text and image attachments. We can see the entire
197:25 conversation history. We can get the list of contacts as well as the chat
197:30 partners. Right. And we exclude our own account from the contacts. Okay. So
197:37 these are the files with the specific changes. The sequence diagram that you
197:43 can take a look at. Basically before every single route we are going to have the arc chat protection with rate
197:50 limiting as well as the protect route middleware just to make our functions um
197:57 you know to to make it authenticated. Okay. Then let's scroll to the bottom and see if we have any suggestions.
198:05 Okay. So here it says you should check for the text and image at least one of them should be provided and then you
198:13 cannot send message to yourself and then receiver if it is found or not. So let's
198:19 actually copy it. I think this is a good suggestion that we can add into our codebase under the message controller.
198:28 Let's say just before this let I'm going to paste this in. Let's get rid of the
198:36 plus. Okay. So if there is like if there is no
198:41 text and there is no image throw this error and if this is the case say cannot
198:46 send message to yourself. Basically, if sender equals to receiver ID, right? And
198:53 here you can see then let's scroll and see if we have anything else
199:01 here. It says the maximum length could be 2,00. Okay, this is something that we could add. Um, let's actually do it. I'm
199:09 going to copy it as well. Paste it under the message.js.
199:19 Okay, so we have added this one as well as the maximum length.
199:26 Again, you can optimize the queries by adding an index and check like at least
199:32 one of these fields should be provided. This is a bit too advanced. I'm going to skip that. Um, and here it says validate
199:41 object ID. Again, it is a little bit advanced. I'm going to skip this. Now let's try to add one more commit.
199:49 Let's say message routes optimized.
200:02 Okay, let's scroll to the top. We should be able to see two commits now.
200:08 Okay, and I'll just scroll to the bottom. Try to merge the pull request.
200:18 And let's get into the master and try to sync this up.
200:29 Okay. So now our codebase is up to date with everything that we have done in the
200:35 in this section. So I believe we are done with the back end section. The only
200:40 thing we are missing is the socket server just to make everything work in real time. Now I will leave it for for
200:48 later sections because I don't really want to make it any more complicated. We are going to build the front end with
200:54 all the functionalities. Uh once you are done with it, we are going to basically implement psych.io from both back end
201:02 and in the front end. And just before we end this section, let's take a look at thev file. We have couple of different
201:09 things that we didn't add into our deployment environment. Right? So go
201:14 under the overview or the deployments, right? Let's actually go here from the
201:20 applications. Select it environment variables and we would like to add couple of different
201:27 things which are all these environment variables other than archet environment.
201:33 So you should add it in development but not in production. So for that reason I'm going to skip that. Let's paste
201:41 everything our chat key cloud secrets and let's say save
201:47 and we would like to deploy the changes with the latest environment variables.
201:52 Right? So this is going to take a couple of minutes. Once it is done we should be good to go. And under the dashboard you
201:59 can see your usage. In my case, I have been using it for a month now and my total cost is like $4, which is really
202:08 good, right? And this basically means they have transparent and easy to understand pricing. And also, there is
202:15 no seatbased pricing, which is a big deal for teams. So, if you're building
202:20 it with your friends or with your colleagues, this platform is definitely worth checking out. And you have $50
202:28 credit. So this actually something that you don't pay, right? Okay. So I hope
202:33 that makes sense. It's been deployed successfully. Let's take a look at it under the deployments. The latest uh
202:42 latest pull request has been merged and it just like it is live without any
202:47 issues I believe. Okay. So with that we're going to leave this section right here and in the next one we are going to
202:54 get started with the front end. So I'll see you there. Now let's jump into the front end
203:00 folder. So what I'll be doing is to open up my terminal cd into it and just say
203:05 mpm rundev and just see the end result. Okay. So this is what we have currently.
203:11 It is the basic react boiler plate. So I'll go ahead and maybe clear this up.
203:16 We can delete this folder. We don't really need it at this point. Um here I'll delete the assets.
203:23 Let's delete the app.css. And under the app.js
203:28 app.jsx I'll delete everything and I'll just say rfce. So this is a snippet that I can get
203:35 because I'm using this extension. Let's say ES7.
203:40 Okay. So if you have this extension as well, you can get the same kind of snippets that I have.
203:48 Okay. I'll just imagine as if you have installed it. So we can save this file and see the end result. Okay. Now, I'd
203:56 like to go ahead and set up the Tailwind CSS. I'll say tailwind CSS.com. In this
204:02 video, we'll be using version 3. So, select this uh version three from the drop down. Now, the latest version is
204:09 four, but this is nothing like old. You shouldn't be using it. No, not at all. This is still pretty valid version. And
204:17 most of the code bases still has version three. So, this is what I'll be using. Uh let's just go under the
204:23 documentation. And from here I think you should select framework guides. Select
204:29 vit. This is what we're using and using react. So we already have a vit
204:34 application. Instead we're going to get this command. Paste this in into the
204:39 terminal. Let's kill the front end. Paste this in. And then next we are going to copy this. Paste it under the
204:46 tailwind config.js file. So this is what we have. I'll delete
204:52 everything. Paste this in and then we are going to get these. Paste it under
204:58 the index.css. Yeah, let's delete everything. Paste this in. And hopefully now everything
205:05 should be working as expected. I'll copy this example and just see if it is going
205:11 to work or not.
205:19 Let's run the front end app and just see the end result. Okay, so we got all
205:24 these styles thanks to Tailwind CSS. Let's say something like text red 500
205:33 and it is working as expected. So this is how tailwind CSS works if you haven't
205:38 used it before. Instead of going into the CSS file and creating your classes
205:43 like card and saying something like padding of 10, let's say 10 pixels and
205:51 then going doing something like border radius, you know, you get the point. Instead of giving a lot of different
205:57 styling here, you don't really need to create a class name. Instead, you would just go here and add everything that you
206:04 would need like flex, you know, items centered.
206:09 Let's type this out. Justify centered. Okay. So, it's really cool. And this is
206:15 what we're going to be using. Now, we can delete this example on top of Tailwind CSS. I would like to use a
206:22 library called Daisy UI. Let's visit this as well. Now the latest version is
206:28 five but we are going to be using version 4. So go ahead select this one. It's going to take you to the version 4
206:35 documentation. And Daisy UI is built on top of Tailwind CSS. So if you're
206:41 wondering what that does, let's say if if in Tailwind CSS you want to get a
206:47 button like this, you had to write all these classes. But if you use a daisy UI, you'll just say something like
206:54 button and button primary, you'll get a similar button, right? And there's
206:59 another example. So if you want to get this kind of an output, you need to write all these CSS classes. But if you
207:06 use Daisy UI, this is like what you're going to get with only couple of
207:12 classes. I hope that makes sense. So we're going to be using this to make everything super fast. Let's say how to
207:19 use. Okay, let's try to copy this. Now, it says the latest, but I think this is
207:24 incorrect. It should be 4.12.24.
207:29 So, let's say mpm install. Um, basically, I'll paste this in, but
207:35 instead of latest, we'll use 4.12.24.
207:41 Okay, that's going to install it. Then, it says go under the Tailwind config.js
207:46 JS and paste this in under the plugins.
207:54 So under the plugins, I'll just say get the daisy UI. So I'll just use the import syntax instead of require. So
208:02 with this, everything should be working out. Let's try to put a button and I'll
208:07 say class um class name btn btn primary.
208:12 let's say my button
208:17 and run the application. Okay. So here we can see we can get a
208:22 primary button just by writing these classes. So that means tailwinds u da is
208:30 also set it up right now. I'll clear up the front end and let's try to install
208:36 react router. Now you can also install this as react router DOM. they basically
208:42 merge them together. Um in this case I'll go with react router because why not? This is the latest
208:49 version. Now here let's try to set this up so that we can have couple of different pages like signup page, login
208:56 page and then the chat page. To be able to set this up we need to wrap our application with something called
209:03 browser router and we need to import it from react router. Okay. Now just by doing this in
209:12 our entire application we can use all the components coming from react router down right okay so let's go ahead and
209:21 set up a couple of them here but first I'd like to go and create some pages so
209:27 under the source I'll say pages and we can create some components as well
209:34 okay so the first page that we are going to have is going to be signup jsx Let's
209:40 have login. JSX as well. And then I'll have the chat
209:46 page. I think I should say login page. JSX.
209:51 And same for this one. Okay. Now, let's say RFC.
209:58 Save. Close. Same for this one. And this one.
210:05 All right. Now, in the app.jsx, I'm going to delete everything. I'll say wrap everything with the routes
210:12 component and then we are going to put specific routes. So the first route that we are
210:18 going to have let's say this is going to be self-closed and path oops let's say
210:25 path and let's import it. So if user visits the homepage we are
210:32 going to show them an element which is going to be our chat page. Right? Let's
210:37 import it. Oops.
210:44 Okay. And let's duplicate this twice. If they visit slash login, we are going to
210:49 show them the login page. And let's do the same thing for sign up.
210:59 Okay, let's test it out. If you're in the I think we need to refresh the app.
211:06 Rerun it.
211:12 Okay, so we are in the chat page. Let's go to login page as well as the sign up. Okay, so
211:19 that means everything is working correctly as expected. And there is one thing that I'd like to
211:26 add to every single one of our pages, which is going to be this grid background as you can tell, right? And
211:33 then this like these decorators, this purple one and then this blue one. So
211:38 this is what we have in the login page, in the signup page, right? As well as in
211:44 the in the chat page. So we don't really want to type this out three different times. Instead, we're going to put it
211:51 under the app.jsx so that every one of these pages has those styles. So I'll
211:57 create a div and wrap them with it. And for the class names let's say class name
212:03 minimum height is going to be screen so that it is taking the entire height. Let's say background slate of 900. Let's
212:11 say relative flex item centered justify center um and let's say padding of four
212:19 as well as overflow hidden. Okay. So that's the very first thing. Now I'll just say decorators
212:27 which are the grid background and let's say glow shapes.
212:34 So head over to the source code under the app.jsx you are going to see this comment and right below it you will see
212:41 a couple of lines of code. Go ahead copy it and paste it. So this is something
212:47 that I have generated. Basically, these are the glow shapes and this is the grid
212:53 background. Okay, so we don't really want to type this out because it looks really complicated and if I have to be
213:00 honest like if you delete this part and tell me to type it out again, I cannot do it. I have generated this with AI and
213:09 I don't really need to memorize it, right? This is something that you are not going to do it by yourself. Okay.
213:15 So, if this is something that you feel like, how am I going to memorize this? Well, you don't need to because I don't
213:21 know either, right? And let's see. All right. So, this is what we have. Looks pretty cool. Create
213:28 background. The glow shapes and the content is in the middle of the screen.
213:33 And this is happening in all of our pages like in the login, sign up, and even in the chat page. Okay. So, I think
213:42 that's it for now. I'd like to show you another setup which is going to be for
213:47 Axios. So let's go ahead open up the terminal. Again under the front end I'll
213:52 say mpm install axios which is going to be a replacement for fetch API. So
213:59 instead of using fetch we'll be using axios. It is a lot more convenient. Under the source I'll have lib and then
214:07 here we can just say axios.js file. And to set this up, all we have to do is
214:13 just importing the Axios from the Axios package. And I think this should be
214:20 imported in this way. Or is it a default export? Let me check. Yeah. Okay. We
214:26 import it in this way. Now we will create an instance. So I'll say export
214:31 con axios instance. And we're going to be using it whenever we do a request. So
214:38 you're going to see it in the upcoming sections. So for now let's say axios.create
214:43 which is going to create an instance and let's put the configuration. So the base
214:49 URL is basically going to be our backend URL. Now if we are in development let's
214:55 say this is how you can access to it import meta.env envote
215:03 you know you can just say if it is equal to development or if it is equal to production so go ahead cut this paste
215:11 this in if you are in the development mode that means we are going to send the request
215:17 to our back end which is localhost 3000/ API but if you are in production we will
215:24 say whatever the URL is just put / API at the end Okay, because we don't really
215:31 know what will be the deployed URL, right? In this case, this is what we
215:37 have. But here we are going to just say it should be dynamic. And also since the
215:43 back end and front end are deployed under the same domain, we just say you
215:48 know send the request to the same domain but slash API. I hope that makes sense.
215:54 And when we send the requests, we would like to include the cookies so that we
215:60 can handle the authentication. We'll just say with credentials should be equal to true. So this is going to send
216:07 the cookies with the request. Okay. So just go ahead save this. This is
216:12 something that we're going to be using a lot later in the video. And then very last thing that I'd like
216:19 to set up is Zastand which is the state management library that we're going to
216:24 be using. Let's first install it and then I'll explain it in detail. So let's go under the front end and then just say
216:31 mpm install zustand and for the specific version we'll go
216:37 with 5.0.3. Okay. So now that we have installed it,
216:42 you might be asking why do we use it in the first place. Let's first run the application and I'll try to explain it
216:49 in detail. So let's say we are in the app.jsx file and we have a state here.
216:55 So I'll say something like my name something like this. Let's import the
217:01 use state and let's say value is something like John. Okay. So let's say we want to use this
217:08 state in both like in all these pages. What can we do is to send a prop right
217:16 like let's say my name and then send this one by one. So you would copy it,
217:22 paste it one by one and to be able to use it, you would go under those pages,
217:28 grab them. Let's say my name and now you can use it. But let's say this has
217:33 another component, right? Let's say something like form. And you need to pass this into here as
217:40 well. So it would be really annoying to do the same thing again and again. Instead of doing it in this way, let's
217:46 actually delete it. So we're going to say instead of creating it in the root
217:51 and passing it into different components we can create it with a store and
217:57 specifically with zust and store. Okay so this is the problem that we have. If
218:02 you want to have a state that is global we always need to create it in the parent component and then share it with
218:09 the children and then if you need to share it again it gets really annoying.
218:14 So let's say login page. Okay. Now let's try to see how we can fix this. I will
218:20 delete these props and go under the source. I will create a
218:27 folder like store and let's say use oath store. This is our very first store that
218:35 we can have and you can create couple of different store. It doesn't really matter like you don't have to have only
218:42 one. Okay. So once again let me try to explain with a diagram. So we will
218:48 create a zoo stand store which you can think think of like a box and here you
218:54 can create couple of different states like some states let's say loading state your name um I don't know like a
219:01 function right it could be anything you would just store a bunch of different things and in your application you can
219:08 use it in any place either in app.jsx JSX or in one of the children, it
219:14 doesn't really matter, right? We can just use it pretty easily. And let's see how we can create a store in the first
219:20 place. So the first thing that you would like to do is importing the create
219:25 function from Zastand. And we'll go ahead. Let me kill the AI. It is kind of annoying. Just snooze this for like an
219:33 hour at this point. Okay. So here you would like to create a hook.
219:39 Let's say export con use use oath store and then we'll call the create method.
219:47 This will take a function. Okay. So we'll just have this function and we
219:52 would like to return an object. So I'll open up the braces and then curl braces
219:57 within that. Now this takes the setter as the first argument and then the
220:03 getter as the second argument. Now most of the time you will be working with this one. But in this tutorial we'll
220:09 also work with the get. For now I'll just get the setter just to keep it simple. And now you can create all kinds
220:16 of states. So let's say something like oath user. And let's say this is a user
220:23 with a name called John. Let's say ID of
220:28 1 2 3. Um age let's say 25. Okay. Then
220:33 we can create another state. Let's say is loading right for now let's just say
220:40 false. And then you can create functions. So let's say login. This
220:46 could be a function. And here I'll just say
220:51 console log. We just logged in. Okay. Now let's try to
220:58 save and try to actually use these states in any of our components. So if
221:04 you want to use it in like in those pages in the app.jsx all you have to do
221:10 just go ahead say use o store and from here now you can dstructure all these
221:16 values which are these ones right. So all user is loading and login.
221:24 So let's say O user is loading and I think we had the login method.
221:32 Let's try to console log the O user.
221:38 Let's say I'll duplicate this. Let's say is loading as well.
221:47 Okay. Now are we running the application? Yes. Let's see. I'll open up the terminal here. We can see we got
221:54 the O user is loading. It is really easy to access to these values, right? We
222:00 just created in a centralized place and we can call them just by doing one line
222:07 of code. So now we can copy this use it here as well, right? It's the same thing
222:13 like super super easy. You don't need to pass props. You don't need to dstructure them. All you have to do is just
222:20 importing them with the hook. Okay. So I hope that makes sense at this point. Now one more thing that I'd like
222:27 to show you is that you would like to use this setter so that you can update
222:32 the state. So let's say is logged in
222:37 initially. Let's say it is equal to false. Okay. Actually I'll delete the loading state here. Uh let's say once
222:44 you click to the login once you call the login method you would like to update
222:50 this to be true. So let's say set and we would like to update this state
222:56 is logged in. Now it's going to be equal to true. So this is how we can use the
223:02 setter method to be able to update your states. Right? Um here let's try to test
223:09 it out. I'll just put a test button. I'll say button login. And if you click
223:15 to it, I'll say on click. We'll just call the login method and
223:21 we're not using the loading state. Let's delete that. Instead, we are using is
223:26 logged in. Okay, let's say
223:33 is logged in. Initially, it is equal to false. But
223:39 once we call the method, okay, so let's see. I'll refresh the page. Is logged in is initially false.
223:47 If I click to this, okay, for some reason I cannot click to it. The Z index
223:53 might be so we cannot see the button.
223:59 Let's say class name Z index of something like 10.
224:04 Okay, now we can click to it. Let's see if I click to it. As you can tell, now
224:10 it is equal to true. So this is how we can update the state. These are the basics of Zastand. But I hope you get
224:18 the point. You create some kind of a box where you can store all of your states
224:24 that are going to be global and you can use it in any of your components. And
224:29 just one more thing, let's say if you had the loading state which was equal to
224:34 let's say false, you can update it as well. So you don't really need to pass only one thing. This
224:41 is just an object. you can put your key value pairs. So let's say is loading is going to be equal to true as well. And
224:48 then you would do let's say some function calls here, right? You would do a couple of different things and then
224:55 you can again just say set um you know you can call the setter
225:01 method and call like make the values different. So all I'm trying to say is
225:06 that you can call this multiple times with couple of different key value pairs, right? Okay. So I hope everything
225:13 makes sense at this point. We can leave this section right here. We just set it up the tailwind CSS daisy UI and the
225:23 routes as well as some decorators. On top of it, we have seted up the ZA stand
225:29 with the Axios Axios instance. Right. So, we're going to be using all of them, I promise. For
225:37 now, let's keep it simple and just try to commit our changes. I'll go ahead open up this status bar and let's say
225:45 open up a new branch. Let's say front end setup.
225:52 And we can stage all of our changes. Let's say something like front end
225:59 codebase setup. Okay. commit publish the branch.
226:06 Let's visit the source code which is this one. Compare and open up the pull
226:11 request and then we'll just wait for some code
226:16 suggestions from code rabbit and then we should be able to merge the pull request.
226:23 So here are the new features that we have introduced which is the client side routing with pages for chat login and
226:31 sign up. Then we have added a login action to update the authentication state. But this is just for testing
226:38 purposes as you can tell from the codebase, right? We are going to absolutely update
226:45 this. This is just testing. Like I just tried to show you how Z stand works in
226:51 the first place and then you can see the rest of it. So we have migrated styling
226:56 to tailored CSS and added the UI on top of it. Here is a quick summary of every
227:03 single file with the changes. The sequence diagram and here is basically
227:08 how our application works. User first loads the application. The render uh
227:14 like we render the root which is main.jsx and then browser router gets
227:20 started so that we can define our routes which are homepage login and sign up.
227:28 Okay. And then this is the login method. How that work? Basically, we just update
227:33 the state with zastand. And then let's scroll to the bottom. Here it says you
227:39 should use react DOM this version. Um, sorry for react router DOM. I think we
227:45 can skip this because this is a like this is a recent change where you can
227:52 basically use react router instead of react router DOM. Maybe code rabbit is
227:57 not aware of it at the time which is fine. Then we can scroll to the bottom
228:02 again. It just says import them from react routerdom. This is not going to
228:07 work but it actually works. It is just a recent change. Okay. So, I'll go ahead
228:13 and maybe merge the pull request
228:20 and then we'll go ahead switch to the master.
228:26 Now, let's try to sync them up with the actual latest changes.
228:33 Okay, so that's it. That's it for this section. In the next one, we can get started with the signup page with all
228:40 the functionalities. So, with that, hopefully I'll see you in the next one.
228:45 All right. So, let's get started with the signup page. Just before we build it, let's try to get rid of these um
228:53 this button in these imports. For now, we don't really need it.
228:58 And just before we get started with the signup page, we have a problem. Let's try to see it. If you try to visit the
229:06 homepage, you can visit this, right? But we are unauthenticated. So it should immediately take us to the login page.
229:13 It says like you're in the login page. You cannot visit the homepage because you are unauthenticated. Right? If we
229:20 try to go here, we should be navigated. So how can we make this work? Well,
229:26 basically we are going to add a check oath functionality. And I'm going to add
229:31 this under the oath store. So let's see. I will actually delete everything that
229:36 we have here. We don't really need it. Let's say we are going to have a state for the oath user and this is going to
229:43 be null initially. Once we check if user is authenticated, we can set this state
229:49 with the user object. And then let's add a loading state like is checking oath
229:56 and initially it's going to be true because as soon as you reload the page we will be checking for this right once
230:03 we check we will say now this going to be equal to false. And then let's put a
230:09 comma and have a method called check oath. Let me turn the volume down. Okay.
230:16 So this is going to be an async function where we will have the try and catch
230:22 block. Under the try we will say con give us a response and we are going to
230:28 call it the axios instance first. Let's try to import it.
230:37 from we'll go one up I believe under the li aios we are going to get this
230:42 instance now by using this we can send the get request to slash now you might
230:49 be thinking why don't we say something like http localhost
230:54 3000 like we don't have to because this is already here right this is prefixed so /
231:01 ai slash oath we will just Okay.
231:07 / slash check, right? Because in the in the base URL, we already have this part.
231:15 So, we don't really need to put this again. I hope that makes sense. So, we'll just say um oath check. And then
231:22 this is going to give us a result back. So, we can say set
231:27 call the oath user state and this is going to be equal to res data. But if we
231:34 have some errors, let's say console log error in oath check
231:43 and then we can say the set o user is going to be equal to null
231:49 because we just failed to we just failed to actually fetch the user state. So if
231:54 we have some errors that means user is not authenticated. And then finally we can just say the loading state is going
232:02 to be equal to false. Let's say is checking oath will be equal to false. So
232:08 either we succeed or fail. Eventually this state should be equal to false. Right now let's go under the app.jsx JSX
232:16 call use oath store and import our values which are the check oath method
232:24 and is checking
232:29 oath and we would like to call this method right if you think about it we just created this but we are never
232:36 calling it so we can create a use effect let's give a little bit space
232:45 And within this I'll just say check oath. Call the method and we should be
232:50 good to go. Now here it says you should pass the check oath which is fine. And then let's say console log something
232:57 like the oath user state. Let's also get that.
233:03 So I'll just put the o user into the terminal.
233:09 I'll try to refresh. Okay. So we cannot send the request
233:14 because we are not running the back end. Let's say cd into the back end mpm
233:21 rundev. I think we are going to get an error again. That is going to be the course error. Right? It basically says
233:29 you cannot send a request from this domain. Sorry from this domain to
233:34 backend. Let's try to fix it. We will go under the back end server.js JS and do
233:40 we have like did we install the course package? Looks like we didn't. So under the back
233:47 end I'll try to kill this. Let's say clear and we will import we will install
233:54 the course package. So go ahead and install it. It is done. We can go under
233:59 the server.js and we will just set this up before our routes. Okay. So before
234:05 here maybe we can just come here and say app do use
234:10 and call the course. Let's try to import it.
234:18 Call the method within object. So the origin is going to be our client URL. So
234:24 I'll say env.client URL and then the credentials let's say is going to be
234:30 equal to true. So this basically says allow front end to send cookies to our
234:36 back end. Right? Okay. Now if you save this and run the back end
234:46 now we shouldn't really get this error. Let's refresh. Okay. So it says internal error. Let's
234:54 see invalid signature. Okay. So I think previously I had the
235:01 JWT in my application for local host like under the application I'll just
235:07 scroll to the bottom I'll delete this JWT. Okay so under the cookies
235:13 select local host if you have the same issue but probably you're not going to have it. Just refresh now we get like we
235:20 got 401 unauthorized. So user is not authenticated. And here we can see o
235:27 user is equal to null. Um if user is not authenticated we should take it to the
235:33 login page. So let's try to do it. I'll go ahead kill this
235:39 and shrink the shrink the left hand side. Sorry. Let's say if user wants to
235:44 visit the homepage and if it is authenticated let's say if we have the oath user okay they can visit but if
235:51 they are not we should take them and navigate them to the let's say login
235:59 page and you would import navigate from the same place. Okay, let's do the same
236:06 thing here. Let's say if user wants to visit the login page, if they are not
236:11 authenticated, they can visit, right? But
236:17 if they are authenticated, we are going to navigate them to the homepage.
236:23 Just pause the video, try to read it. You're going to understand. And let's do the same thing for sign up.
236:31 If they are already authenticated, they cannot visit the signup page. We will just take them to the home. Okay. So,
236:38 I'll try to go to homepage. I cannot. I'm just in the login page immediately.
236:44 And we can put some loading check right here. I'll say if is a checking oath.
236:54 In this case, we can return a page loader component.
237:00 And let's try to create this under the components.
237:06 So I'll copy the name and let's say loader.jsx. And in this file we are going to be
237:12 using an icon. Let's go under the front end and try to say npm install lucid
237:18 react. So this package is going to give us bunch of different components or
237:24 icons. Let's say here we'll have the class name of flex item centered.
237:33 Okay. Why we cannot get the auto suggestion? So I just added item center
237:38 to justify center. So I have just added item center justify center and then the
237:44 hide screen so that it is taking the entire page. And then we'll say import the loader icon. Let's put some classes
237:52 as well. I'll say size is going to be equal to 10 and animate of spin. Let's
238:00 try to import the loader icon from lucid react.
238:09 Okay, now we can run the front end. Let's save. Go right here and try to
238:14 import this component. Okay, so for a split second, as you can
238:21 tell, we have the loading state. If you just say true, you can see it. This is
238:26 the end result. Okay, so I hope that makes sense. Now with this check, we have the
238:34 authentication state working correctly. If user not authenticated, they will be
238:39 redirected to the login page immediately. And if they are authenticated, they will be in the
238:44 homepage. So they cannot visit login or sign up pages. Okay, perfect. Now we can
238:50 close everything and go under the signup page and just get started with the
238:55 actual functionality. Under the signup page, we need to have three different states. One for the full name, one for
239:03 the email and for the password. So let's try to create it. Instead of doing it
239:09 separately, I'll just create it under the form data. Let's say set form data
239:16 and this is going to be an object. Let's say use state and for the initial state
239:22 we can say full name will be an empty string. Let's kill the left hand side
239:27 and do the same thing for email. And for the password okay then we're going to
239:33 have a method so that we can you know submit the form. I'll say handle submit.
239:40 This is going to take the event and we'll do it something in a bit later in the video. Um then we need to have the
239:47 actual sign up method. So let's say we are going to get the sign up as well as the loading state which is is signing
239:56 up. We will grab this from oath store.
240:04 Okay let's try to import it. Okay, I just imported it. Now let's try to create this under our store. So I'll
240:12 have the loading state is signing up. Initially it's going to be equal to false. We can shrink this and have the
240:20 sign up method. Let's say it'll be an async function. We are going to get some
240:25 data which is the full name, email and password. And we're going to do something within this function, right?
240:33 Okay. So let's say we'll have the try and catch block. Before we try to do anything, let's set this as the true,
240:41 right? We'll say set is signing up. Oops. Let me just copy
240:48 it. And I'll say this is equal to true. And finally, it's going to be equal to
240:53 false again. So I'll copy this.
240:58 Okay. Now under the try we would like to send a request to our endpoint and this
241:04 time it's going to be a post request right here we just said get request this
241:10 time it is post and we're going to send the data so that we can sign up and then
241:16 we're going to get some response back where we can update the oath user with it because if you take a look at the
241:23 oath controller in the signup method let's see where that this
241:31 this is the sign up method. Okay. So I think we are not sending the
241:37 user I was going to say but here we go. Once user sign up successfully we sent
241:43 the user back right. So we are taking this and updating our state with it. I
241:49 hope that makes sense. And then um here we can show a notification with to host.
241:56 Let's see what I mean. There is a package called React hotost
242:04 and basically they have these kinds of beautiful notifications you know for success error promise and you can
242:12 customize it with emojis all kinds of stuff. So we'll be using the success and error most of the time. Let's try to
242:19 import it first. Under the front end say mpm install react
242:26 host and then let's run our application
242:31 again. We will go under the app.jsx. To be able to use it, you need to import
242:38 this component in some place, right? So here I'll just put it after the routes
242:45 and let's try to import it. um from the package I think it should be
242:53 something like this poster from react hot toast okay now we can basically say
243:01 something like toast success and just put your message something like
243:07 account created successfully
243:13 and you need to import the toast just like this okay In the catch you can put a console log but I'll just put toast.
243:22 And here I'll say error response dot data dot message. So this is how we
243:30 can access to the error um in Axios. Okay let's just try to test this out.
243:36 This is the method that we have. We are updating our loading state. Send the request update the oath state. show a
243:44 notification and eventually set this state to be false. So we are going to
243:49 call this method under the sign up page once we submit the form. But first let's
243:54 try to build the UI. So here we will have a div with some classes which is
243:60 with full flags item center justify center so that everything is centered
244:06 correctly. give some padding from all directions and then we'll be using this background slate of 900 color right then
244:14 I'll have one more div again with some classes which is going to be this one so
244:20 relative with full maximum width of 6 x large so it cannot get larger than this
244:27 if you take a look at the end result so it has a maximum width right it cannot
244:33 go larger than this we don't really want this to happen and it has a maximum
244:38 height as well. Here you can see this is the maximum height and width and this is
244:43 the class name it is coming from. So here we say if we are in the medium screens and above height should be 800
244:52 pixels but if we are in smaller screens height should be 650 pixels. So this is
244:58 how we can make responsive design with Tailwind CSS. You can add even more
245:04 things like large um large break point X large things like that. I hope that
245:11 makes sense. And right after this I would like to put the animated border
245:16 container. So here as you can tell there is this border that is just going like
245:22 animated. It goes from here all the way up to you know it just moves the entire
245:29 rectangular right. And we have this in in the signup page in the login page as
245:35 well as the chat page. So we don't really want to build this three different times. Instead we are going to
245:41 build a component just once and we can use it in all all these places. So I'll
245:48 say border animated. Let me give a little bit space.
245:55 Container.jsx. And before I built this, I just did a quick research and found this website.
246:04 You can find this from the source code. Let's try to visit.
246:09 Okay. So basically this is the example that I take a look at and you can see the tutorial if you really wanted to.
246:15 This is what I have done. I just see the code example and try to integrate it to
246:21 my codebase. So basically we need to import this and put it into our CSS
246:27 file. So go ahead find your index.css. Paste this in. You can grab this from
246:34 the source code by the way. And then under the tailwind config just copy this
246:40 entire theme. And we're just going to paste it
246:46 in this file. So for this theme, we just extend by adding an animation for the
246:52 border and a key frame. Okay. So now we can go into this component. Again, you
246:59 can grab this from the source code. This is what I'm going to be doing. Just copy it and paste it. It looks really ugly.
247:08 If you delete it and tell me to do it, I cannot. I swear. I just get it from the
247:14 example. Okay. Save. Now we are going to wrap this
247:20 children with the actual component. So let's create a div and we're going to
247:25 see the end result. I'll say class name with full flex flex column. But in the
247:31 larger screens it's going to be in the row direction. So here this is a large screen. We see
247:37 it in the row direction. Right? We have something on the left something on the right. But if screen was smaller we
247:44 would not see it right? we would only see this part. I hope that makes sense.
247:50 And then let's try to see what we're going to have within this. First, we will have the form column which is the
247:57 left side. Okay. Once we build the left side, we're going to have the right side which is the image. So, I'll have a div.
248:05 Again, let's give some classes. Now, this is not a CSS course. For that reason, I'd like to just paste it and
248:12 walk you through it. So we have the width which is 50%. Padding 8 from all
248:19 directions flex item center justify center will give the border and a color
248:26 which is border slate 600. Now I don't really know why tailwind CSS auto
248:32 suggestion doesn't work. I'll say command shiftp and reload the window.
248:40 Hopefully this should fix it. Sometimes the VS code is kind of annoying. Okay,
248:45 now it is working. So this is the solution. If you know if it doesn't work
248:50 in your case, just type reload window and run this. Okay, now within this I'll
248:57 have a div with the class name, width of full, maximum, width of medium, and then
249:04 I'll have one more div which is going to be for the message circle icon. So let's
249:10 see. Okay. Basically, we're gonna build this part. Message circle icon and the
249:16 title. Okay. So, let me grab this.
249:23 Paste this in. Four lines of code. We have a text center message circle icon
249:29 from Lucid React and heading two as well as a P tag.
249:34 Okay, I'll just get the message circle icon from Lucid React.
249:40 And we'll be also using these icons. So just go ahead and import every single one of them. And just to make this look
249:47 a little bit more beginner friendly, I'll just put some comments like let's say the heading. Let's say heading text.
249:56 Right after this, we can put our form, right? So I'll say form,
250:01 we're going to create this form element. It doesn't need any actions but on
250:06 submit we can call the handle submit method that we have created above and
250:13 then I'll say class name space y of six
250:18 so that every single element has some spacing right so this is space y six six
250:25 here and here as well okay now we're going to build three different input elements one link I mean
250:32 one button and on a link.
250:38 So the first one is going to be a div for the full name input. So I'll have a
250:44 label element and let's say the class name is going to be now we will do the
250:51 same label three different times and instead of doing you know something like
250:56 this so just follow along with me. So we are going to have this class for
251:02 the label let's say and later we will have the same label again and then again
251:08 then again. So we don't really need to type this out four different times. For that reason I will create a class called
251:17 both input label. Okay. So this is the reusable
251:23 class that we can create in a second and this will say something like full name
251:29 and right after the label we're going to put a div. Let's say this will have the
251:36 class name of relative and then it'll have the users icon sorry just user icon
251:43 coming from lucid react. We can give some classes. Let's say oath
251:50 input icon. Again, this is reusable.
251:55 Then we'll just have the input element. So let's say type will be text.
252:02 Oops. Let's say value. Value is going to be coming from form data and
252:08 specifically the full name field. Then on change
252:15 let's say on change we will get the event again AI is kind of annoying but
252:20 let's say we will keep everything as it is but just update the full name field.
252:26 Um we can add a class name like input which is coming from DUI and then for
252:32 the placeholder I'll just say John do. Now let's try to create these classes.
252:38 For this we will go under the index.css. CSS and let's see how we can create
252:43 reusable classes with tailwind. Um basically you would give the name let's
252:49 say dot oath dash input dash label
252:55 right. So this is the name that we have given and then for the styling you would
253:00 say at apply and we are going to apply all these
253:06 tailwind CSS classes. So what we have just done instead of typing this out
253:11 three different times right so let's say input label so we just put this okay
253:18 instead of here we just put it right here because we are going to be using it a couple of different times so go ahead
253:24 and get the input as well so this is what I have for the input class um for
253:31 the input label icon basically we will have couple of different of them just
253:38 get it from the source code. Okay, just paste this in. This should be good to go.
253:44 All right, so let's try to zoom in, save, and test out the end result under
253:50 the signup page. Okay, so this is what we have. This is
253:56 the animated border. It works really nice and I think the input also looks
254:02 pretty cool. Right now, let's try to put a comment here. I'll just say full name
254:10 and I think we can copy this, paste it and call this as email. So it'll be the
254:16 same thing. Say email input.
254:23 For the label, we would say email.
254:28 And for the icon, I'll use the mail icon this time.
254:34 If I can type correctly. Okay, type is going to be email. Form data would be
254:40 email as you can tell again. Um, class name is just going to
254:46 be input or the placeholder. Let's say John do atgmail.com
254:54 and just give it a go. Okay, so I think it looks pretty cool. Now let's do the
254:59 same thing for the password. I will basically duplicate this. Let's
255:06 say password import. I mean password input.
255:11 Let's try to update it pretty quickly. Password. Let's say password type is
255:19 going to be password as well. Um here we can just put couple of
255:25 different let's say asterisk.
255:30 Sorry. Actually, let's just say you know enter your password
255:37 and just see the end result. All right. Now, we would like to put this button and this is going to say create account.
255:44 But if you click to it, we are going to be in the loading state. So, we can say something like is signing up or we can
255:52 show some kind of a loading icon, right? So let's try to do it here. Right after
255:57 the password input but still within the form we will create
256:03 a button. Let's say submit button.
256:11 Okay. For the class name I'll say oath dashbtn.
256:16 Um type is going to be equal to let's say submit. Oops. Let's say submit. And
256:23 this is going to be disabled if you are in the loading state. So is signing up
256:29 so that user cannot click to it multiple times. Um if you are in the loading
256:34 state as I said I will show an icon. So if we are signing up see the loader icon
256:40 with these classes but else just say create account. Okay. Save. And right
256:47 after the form we are going to have this link so that it would take us to the login page.
256:53 Okay. So, right after the form, paste this in four lines of code. Import the
256:59 link from React router. Okay. Now, from Lucet React,
257:06 say import from React router just like this. And
257:12 once you click to it, it would take you to the login page. Here is the class name.
257:19 Okay. So, I'll click to it. I am in the login and let's try to sign up. I'll open up my database so that we can check
257:27 it out. Okay, I just logged in. Under the users, we have three different users. Right now, let's try to sign up
257:34 with a different account. I'll say something like Bob uh let's say Bob do.
257:40 And this is the email atgmail.com. For the password, I'll just put one, two, three.
257:46 Okay. So I think it did not work because we forgot to say event dot prevent the
257:53 default, right? We are going to add this so that it doesn't refresh the page and
257:59 we also forgot to call the sign up method. So we're going to pass the form data. Now it should actually work. Let's
258:06 do it again.
258:13 Okay, I'll just say 1 2 3 and it should throw us an error, right? This is coming from the back end. Now let's put 456.
258:22 But don't put email. All fields are required. Okay, perfect. Now let's say
258:28 create account. Account created successfully. We are navigated to the homepage by the
258:35 way, right? And let's try to refresh. We should be able to see four different
258:41 users and this is the one that has just been created and you can open up your
258:47 dev tools and under the application and by the way this is how you can open this. You could just say inspect, select
258:54 the application under the cookies, select localhost, scroll to the bottom,
258:59 you should see something like JWT, right? We just set the cookie as you can
259:04 tell. So it is working completely. So the only thing that we are missing in the signup page is this um it is this
259:13 kind of like the right hand side, right? So now how can we log out? Because
259:19 currently if you try to visit the signup page you cannot. So we don't have the log out functionality but you can go
259:26 under the cookies you can delete it and if you refresh now we are not logged in
259:32 right because it is the token that keeps you logged in. Okay now let's try to put
259:38 the image and I think that would be it for this section. So let's go into the VS code and under the public folder
259:46 you're going to see a couple of different images from the source code. Okay. So just go ahead see the source
259:52 code. You will have three different images. You can copy them and paste them right here which is the avatar, the
259:59 login page image as well as the signup. And then you're going to have a folder
260:04 for the sounds. Okay. So we have the keystroke which is like keyboard sound.
260:11 Okay, we have mouse click and a notification sound. So, we will be using
260:16 them, but for now, we would like to use the signup.png in this file. Let's scroll to the
260:23 bottom. Um, right after this left side. Okay, just shrink this. We're
260:31 going to put another div. Let's say form um illustration. Basically, say this is
260:38 the right side. Okay. So let's create a div with some classes. I'm going to
260:43 paste this in. So this is going to be hidden in smaller screens but medium screens and above we are going to see it
260:50 and it'll take the 50% of the width. Um it'll be flex medium screens and above
260:56 but else it would be hidden right and here are some background gradients just to make it look nice. Here I can zoom
261:04 out so that you can see it clearly if you want to type it out. Then we are going to have a div with the image. So I
261:11 don't want to waste too much time on the styling. I will just paste this in around 10 lines of code. And you can
261:18 pause the video, type it out if you really wanted to. We are using the signup image with these classes and then
261:25 1 H3 with some badges. Okay, let's save and take a look at the output. This is
261:32 what we got. The image, the title, as well as the badges. I think this looks
261:37 pretty cool. Pretty cool and clean, right? And it is responsive as well. So once you hit this endpoint like break
261:45 point, it has just gone. You can only see the actual form.
261:51 Okay. So we're going to do the same thing for the login page in the next section. For now, we can commit our
261:58 changes under a new branch. So just before we commit our changes, let me
262:03 pretty quickly walk you through it what we have done in this section. So basically we created a sign up method so
262:10 that we can sign up the user and if everything is done successfully we are going to update our oath state and show
262:18 a success message. Right? Then we have a loading state. So under the signup page
262:24 we have a form data. We are getting these methods as well as these states
262:29 and we are calling them once we submit the form. Right? And the rest is just
262:34 UI. There is nothing special here. That's what I believe. When you type into the input, we
262:40 basically save the state. Um, and basically that's it. There is nothing else. And if if you are in the loading
262:48 state, we just disable the button and update the UI accordingly. Okay. So I
262:54 think that's pretty easy to understand. You can just pause the video and go through the codebase. I'm 100% sure that
263:02 you will understand it. Okay. So let's close everything. You can just zoom in
263:09 and just try to create a new branch this time. Let's say sign up. Okay, we
263:17 already have it. Let's say sign up front end maybe.
263:24 stage all of our changes and say something like sign up implemented
263:31 on the front end commit and publish this branch. Let's go
263:38 into the source code and create the pull request.
263:45 Okay, as usual, I'll just wait for the suggestions and then we should be good to go. So here are the new features that
263:52 we have introduced in this section. We have added the cross origin support to enable authenticated requests from the
263:59 client. We have implemented the oath check, right? And then we have introduced a full screen loading state
264:06 with the page loader component. Then we also uh we also implemented the signup
264:12 flow u that is working perfectly fine. So you can pause the video if you really
264:18 wanted to see the summary. Same for the sequence diagram. This is basically
264:23 where we have the oath check like what is happening. And then same for the
264:28 signup. Okay, let's see what we have for the suggestions. It says you can add the
264:34 with credentials equal to true but we have it in the Axios I mean in the Axios
264:40 file, right? So, we have it as a global option. So,
264:46 we don't really need to add it. Um, here it says you can fix the errors, you
264:51 know, make it a bit better. I think that's fine. And then we don't really need to add this one because we have it
264:58 in this file once again. Okay. So, I'll just go ahead and merge the pull request.
265:07 And then we can basically switch to the master
265:13 and sync things up, right?
265:19 Okay. So now our codebase is up to date. In the next section, we can implement the login page.
265:27 Now we are going to get started with the login page. Just before we build the page itself, let's go under the oath
265:34 store and try to create the login function just like what we have here. So
265:39 I'll basically duplicate the signup method. If you wanted to, you can type it out, but I'll just create this login
265:47 based off of the sign up method. So again, we're going to get some data which is the let's say
265:55 like it is the email and the password, right? If user wants to sign in, they need to send these details. So we're
266:02 going to grab this as the data and let's try to have a state for is logging in
266:13 and initially this is going to be equal to true. We are going to send the request to o login and if everything is
266:20 done successfully we can just say you know logged in successfully.
266:27 Okay. And I think I'm going to delete the exclamation point. And eventually we
266:33 will say set the state the loading state to be equal to false. All right. So
266:39 that's the entire method. Let's leave it as it is. Then we will go into the login page. So the content is almost the same
266:46 with the signup page. What I'll be doing is copy the entire return statement
266:54 and paste this in. We're going to fix it, I promise.
266:60 And let's try to get the same logic. Okay. In the form data,
267:08 first let's import the use state and o store. We don't really need to have the full name. And we don't really want to
267:15 get the sign up, but instead, let's say we're going to get the login and is
267:20 logging in. Let's put the login. Now we can scroll
267:26 to the bottom here. Let's instead use is logging in. Okay. Now for the content
267:33 instead of create account it should be something like sign in right or login.
267:41 And for the link we will say don't you have an account like don't have an account go ahead and sign up. If they
267:48 click to it this would take up to the sign up screen. And let's scroll to the top. We can
267:55 delete the full name, right? So this is the full name. Just go ahead delete that. For the title content, we are
268:04 going to put welcome back. Login to access your account.
268:11 Say welcome back
268:20 your account. let's say. Okay. So, let's see what else we need to update. Um,
268:27 these are going to be the same. Email, password. I think that's it, right? Uh, maybe the very last section. Connect
268:36 anytime and anywhere.
268:45 Okay. So, believe it or not, we are done with the login functionality. So, let's try to test it out here. Um, why do we
268:54 have an error? Let's see. I think we don't have the imports. Okay, so it says you don't have this
269:00 import. And I think we don't have the icons as well. So, let me copy all of
269:06 these. Um, paste it right here. We are not using the user icon, the log icon.
269:14 Let's see if the icons are correct. Um, we have something else. Let's see link
269:20 is not defined. Okay, let's get the link as well.
269:28 Okay, so here icons are not correct. Let's see this is the password and this is um log in.
269:38 Let's see mail icon. And here in this one let's say log in or
269:44 log icon. Okay, now this is looking correct but we are
269:50 unauthenticated. So let's try to log in. I'll say we had the account
269:56 jondo@gmail.com. Let's put the wrong password invalid.
270:01 Okay, let's say 456 which is the correct one. Now we are logged in successfully
270:06 and we are in the homepage. And just for testing purposes, I am going to put a
270:11 log out button into the homepage. under the chat page, let's say um button log
270:19 out and let's try to actually implement it. But of course, later in the video, we are going to put the log out button,
270:27 you know, into the header. But for now, let's just try to test it out. When we click to this button, we would like to
270:34 call our logout method, right? So, we're going to dstructure the logout from our
270:40 hook. And we don't have this method. Let's try to create it. We'll say log
270:46 out and maybe you can just pause the video and test it out if you can build it by yourself. Right? So we'll have try
270:53 and catch block. Log out is really fast. So we don't really need to have a loading state for this. I'll just say
270:59 await axios instance post method to our endpoint. And then if this is done
271:05 successfully, we can just say toast log I mean toast.uccess log. successfully.
271:11 And just before that, let's set the oath user to be null because we just logged
271:17 in. Sorry, we just logged out. And then in the catch, we can say error logging
271:22 out. If you really wanted to, you can console log this. Okay, that's it. Now,
271:27 let's go here. We got the log out on click. Let's say we're going to call
271:33 this method. And I think we cannot click to this button.
271:39 I'll just say class name something like Z index of 10.
271:45 Okay. Now if I click it, we are logged out successfully. We are in the login
271:50 page. And this is what we have for the signup page. And I just realized that these icons are not correct. Here we
271:57 should have the log icon. Let's fix it. Under the signup page,
272:04 we have the import but we are never using it in the password import. This
272:10 should be log icon. Okay. So once again log functionality is
272:17 really easy to build. All we have to do is just adding the method and calling it
272:23 once you click to a button. And since we are updating this state to be equal to
272:30 null in app.jsx, you know, one of these is going to run
272:35 and we will be redirected to the login page. So we are in the homepage, right?
272:40 We just logged out. This is going to be equal to null and you will be navigated to login. Okay. So this is how that
272:47 work. Everything is in place. We have the errors, success state, everything
272:54 works as expected. Um here I think we can update the image for the login page.
273:00 This is one more thing that I just realized. Let's see the right hand side.
273:07 And here this should be login.png.
273:14 Okay. Now we can commit our changes.
273:22 I'll create a new branch. Let's say login front end
273:29 stage all of our changes. Let's say login and log out implemented.
273:36 Okay. So I'll just commit this. Let's publish it
273:43 and create the pull request. So as usual I'll just wait for the
273:48 suggestions from code rabbit. So the new features that we have introduced are the
273:54 sign-in page as well as the logout functionality. You can take a look at the quick summary that we have here as
274:01 well as the sequence diagram. It looks pretty clean and crisp like when you send the log out request. You would
274:09 clear up the oath user state and show a success message. And behind the scenes,
274:14 this would uh this would clear the cookies, right? And let's scroll to the bottom to see some suggestions. I think
274:23 we have a typo under the login page. Let's try to fix it. Like in login
274:29 state, I am missing the G keyword. So let's go under the login page.
274:39 Okay, this should be is a logging in just like what we have here, right?
274:46 I'll copy this and scroll to the bottom and fix those.
274:55 And what else we have? It says you can add a state for the logging out the
275:01 loading state. I think that's fine. I'm not going to add it because it is happening super fast. Now, since we have
275:07 a change under this branch, let's try to commit this. I'll say fix typo
275:16 sync this up and we should get this as a new commit.
275:23 Right, we have two commits. Now we can basically merge this pull request.
275:32 Okay, let's go back into the master and get the latest changes.
275:41 Okay, so with that everything is up to date. I think that's it for the login page as well. Hopefully, I'll see you in
275:48 the next section. Now, it is time to get started with the chat page. Just before we write any
275:55 code, I'd like to show you the states that we are going to need in this page. Okay, so the first state that we are
276:02 going to create is the active tab. That's either the chats or the contacts,
276:07 right? If you click to the contacts, that would be active. And we would like to keep track of the state. And we would
276:13 like to have one more state to be able to store our contacts coming from
276:19 database. And same for the chats, right? Um the other state that we are going to
276:24 need is if this sound is enabled or not. Right? That's going to be a boolean
276:30 value. And then one more state if we have any selected conversation. Right?
276:36 So if you click to this UI is going to update and you're going to see the messages between you and this user.
276:43 Okay. So I think we will have some loading states as well. But I think we just got the point. So let's go under
276:50 the source right. Let's just go under the front end source. Under the store I
276:56 will create one more store that is related to be chats. So we have one
277:01 store all already which is related to authentication. Right now we'll create
277:06 one more that is related to chats. So I'll say use chat store.js file. Okay.
277:13 Let's try to see how we could create a store. So if you remember we need to
277:19 import the create method from Z stand. Right. And then we'll go ahead say
277:25 export con use chat store. And I'd like to kill the AI so that it's not really
277:33 annoying, right? Okay. So here I'll say call the create method and this is going
277:39 to take a call back function where we would like to return an object. Okay. So
277:44 this is the signature. Just go ahead memorize this so that you can have an easy time like easier time to just
277:52 follow along with the tutorial. It's completely fine to memorize this. Basically you call the create method and
277:59 then pass a callback function where you return an object. Okay. Now let's try to
278:04 put our states. So I said we are going to have one state for the contacts. So
278:09 you say all contacts and this is going to be an array. And then we are going to
278:14 have one more for the chats. These are going to be our chat partners. And then
278:20 for the messages initially they are going to be empty arrays. Once we fetch
278:25 them, we are going to update the state and then the active tab. Let's say by
278:31 default it's going to be the chats, right? If you refresh the page, you
278:36 would like this to be active initially. Okay? So that's why we will go with this
278:42 value. Let's say selected user initially it's going to be equal to null. Um then
278:49 I think we will have the aloing state. Let's say if I mean is users loading
278:56 initially it'll be false let's say and then is messages loading and once we use
279:03 them I think you will see this in action for now let's say false as well now one
279:09 more thing is sound enabled which is going to be either true or
279:15 false now how can we decide this well we will get the value from local storage.
279:21 So I'll say local storage.get item and you can pass any key. I'll say is sound
279:28 enabled. Let's say if this is equal to true
279:33 then this will be equal to true. Right? Otherwise if this is not existed or if it is equal to false um this will be
279:40 equal to false as well. Okay. So these are all the states. Now we would like to create some functions. Let's make the
279:48 first one. Let's say toggle sound. So when you click to this button, you would
279:54 like to toggle this state. If it is true, it's going to be equal to false. And if it is false, it would be true. Um
280:02 here I'll say this is going to be a function. So let's go ahead and say something like first update the local
280:08 storage. And make sure to put a comma here. Let's say set item. And let's pass
280:15 our key is sound enabled. And then we'll say uh you know just negate the value.
280:22 So we are going to take this value. Let's say get the set. Let's get the set
280:28 as well as the get. Okay. So here I'll say first call the get method. And from
280:35 here we can select any of these states. So I'll get this one. And we are going
280:41 to say whatever the value is just negated. Okay, I hope that makes sense. Um, and then within this we will say
280:48 set. Now we would like to update this state. So I'll say is sound enabled. And
280:54 again we will just do the exact same thing.
280:59 Okay. So once again first we updated the local storage right and then we also
281:05 update the state so that we can uh update the UI immediately.
281:10 Now we are going to save it to the local storage so that if user refresh the page
281:15 we should still keep track of the state right um or even if they leave the
281:21 website and then come back in like 2 days later we should still want to have
281:26 their preference so that's why we are using local storage in the first place and then let's say
281:33 set active tab this is going to be the setter method
281:38 user is going to pass a tab that is either chats or contacts, right? We are
281:45 going to call it the set method and we'll say selected sorry the active tab is going to be
281:52 equal to this tab that user wants to have. Okay. So let's do the same thing
281:57 for set selected user. user is going to pass
282:04 a selected user and we'll say selected user will be
282:10 equal to that value and since they are the same thing we can just shorten this okay so these are
282:18 pretty basic functions uh once we use it I think they will make more sense and on
282:23 top of these I'll just put two more functions so one is going to be to get
282:28 all the contacts right let's say get all contacts and this is going to be an
282:34 async function. Let's try to just initial initialize it for now. And then the other one is to get I think I have a
282:41 typo by the way. Let's say get all contacts and then this is going to be get my chat
282:50 partners. Okay, now let's try to build it. It's actually pretty simple. You can
282:56 basically pause the video and try to build it by yourself. um you need to update the state before you do anything
283:03 else. So since we have done similar thing, I'd like to just copy and paste it and walk you through it. So we have
283:11 like we are updating the state to be true initially. Then we have try catch
283:16 and finally blocks. So here we would like to import axios instance and then
283:21 send a request a get request to this endpoint. Then we're going to update our
283:27 state with the response from the back end. And if we have any errors, we can
283:32 just show a toast as an error, right? And then finally, we're going to set the
283:38 state set the loading state to be false. Now, let's do the same thing for this
283:43 one. Again, you can basically build it by taking a look at this one. But since
283:49 I don't want to waste any time, I'll just paste this in five lines of code. We update the state, send a get request,
283:57 update the chats state, right? Um, and then just have the catch and finally
284:03 blocks. All right, so that's the entire thing. Now we can go into the chat page
284:10 and get started with the UI and then we are going to be calling these functions as well as the states.
284:18 So first let's try to delete this button. Delete the content and this is
284:24 going to take the relative let's say with fold maximum width of 6x large and
284:31 then the height is going to be 800 pixels. Okay. So if you want to give some custom
284:38 values this is how you can do it with Tailwind CSS. Now I'd like to wrap everything with the border animated
284:46 container. Let's try to import it.
284:51 Let's say import this component from let's go one up
284:59 under the components and get this one. Okay. So within this we are going to
285:05 have the left side as well as the right side. Right. So here I'll say left side.
285:10 Here we'll have a div with these classes. Let's say width of 80. Um
285:16 background of slate, let's say 800. And we can update the opacity with 50. Um
285:23 here I'll say backdrop blur of small flex and flex of colum. So this is
285:30 basically the sidebar that we are building. The first component that we are going to have is going to be the
285:36 profile header and then we are going to have the tab switch and then the you
285:43 know like this is going to be the container that we will display either the chats or the contacts. So let's get
285:50 started with this one here. I'll say show the profile header component
285:58 and right after this we will have the active tab switch
286:06 and then here I'll have a div let's say class name of flex one overflow y of
286:13 auto heading of four from all directions and let's say space y of two so here we
286:21 will say something Like if the active tab is equal to chats, we're going to
286:28 show the chats list.
286:35 This is a component that we are going to create. But if it is not equal to chats, we will show the contact list.
286:46 Okay. So let's try to get this state from not oath store but from use chat
286:53 store okay so I think this should be equal to
286:59 use chat store and then we will get the active tab okay
287:06 let's try to save this file and create all these components one by one so I'll
287:11 copy this name let's say jsx get rfcee save it and leave it as it is for now.
287:18 Let's do the same thing for this one
287:24 and this one.
287:32 And then finally for the contact list, let's say JSX.
287:41 Okay, now let's try to build the right side as well. Just go outside of these
287:46 two divs. Create this comment. Let's say right side. And we'll have a div. Let's
287:54 say class name is going to be likes of one leg of column. Um we'll have the
288:01 background select of 900 and I'll update the opacity. Then finally backdrop blur
288:08 of small. So within this we will say if there is a selected user and let's grab
288:14 this state from here. Okay. So we'll say if there is a
288:19 selected user then we can show the chat container. This is a component that we
288:25 are going to build and like if there is no selected user right we would like to
288:32 see this kind of a placeholder where it says select a conversation to be able to
288:37 start messaging. If a like if a user selected this is the chat container.
288:44 Okay. So let's say no converation
288:49 placeholder. Let's try to create these components
288:57 RFC. And let's do the same thing for this one. Oops. Let's say cancel.
289:14 Okay. So now we can import every single one of these components.
289:29 Okay. So basically I have imported everything from the components folder
289:34 without any issues. And I just realized here in the chat store, this should be
289:40 chat store, right? Not oath store. So this is something that I just realized.
289:46 I think I just had a typo here. Let's fix it. Save. Now we shouldn't really have any problems.
289:53 Okay. So if you refresh, we don't really have any errors other than unauthorized, which is not really an error. It
289:59 basically says you are not authenticated. Okay. Let's try to log in. I'll just put
290:05 this account say johno@gmail.com
290:12 once we are logged in this is the UI that we can see okay so we're going to build all these components one by one
290:19 but I think we can get started with them in the next section so for now I'd like to keep this section sweet and short
290:27 right um we have created the chat page basics right we just put the layout with
290:34 all these components as well as the chat store where we have couple of different functions as well as some states. Okay,
290:43 so let's close everything. Now we could create a new branch since this is pretty basic. We haven't really done anything
290:50 related to logic. I'll just go ahead commit my changes right under the master. If you wanted to, you can create
290:57 a branch at this point. You know how to do it. Um here, let's actually do it. I
291:03 don't know just to make everyone happy here. I'll say the branch name. Let's say uh chat
291:10 page setup. Okay. So I just created the branch.
291:16 Let's say add them to the staging area. Um for the commit message, let's say
291:22 chat page layout setup
291:28 commit and publish the branch. Let's go into the source code
291:39 and we are going to create the pull request. Now if you wanted to you can wait for
291:46 the code suggestions that are coming from code rabbit but since this section was pretty easy I'll just go ahead merge
291:53 the pull request without waiting for the code review. Okay. So, let's try to sync
291:60 this up. I'll go into the master and let's try to get the latest changes.
292:08 Okay. So, it is done. Everything is up to date. Let's take a look at it. These are all the components that we have
292:14 created in this section. Right now, in the next section, we can get started with the sidebar component. Okay. So,
292:22 hopefully I'll see you there. Now let's get started with the profile
292:27 header component which is going to be this one. So here on the left hand side we will have the user image, username,
292:34 the online text and then these buttons. So when you click to this image it uh
292:40 like it should allow you to upload an image from your laptop. So let's see how we can build this. Um and if user
292:47 doesn't have any images this is the default image that we are going to use which is coming from the public folder.
292:55 Okay, so it is this one. Now let's go into the profile header component and
293:00 just try to build it. So first I'll get couple of different imports. Let me just
293:05 copy and paste them. It is four lines of code. We are going to get use state and user app from React. We will get some
293:12 icons and our stores from the store folder. Now from the oath store, we are
293:19 going to import the log out O user and update profile states. Then from the
293:24 chat store we are going to get the state for the sound and then the method to be
293:30 able to toggle the state and then I will have one more state which is to check if
293:35 user has a selected image or not. Initially it's going to be equal to null and then we will create a ref as well.
293:42 We'll say const file input ref and let's say use ref. You're going to see how to
293:49 use it. Initial value is just going to be null. And right after this I will have a function. Let's say con handle
293:57 image upload. Okay. So for now it is just going to be an arrow function that is going to take
294:04 the event and we'll build the logic in alpit. So first let's try to build the
294:10 return statement here. This is going to take a couple of different classes like padding of six. Let's say border
294:17 dashbottom. And let's give the border color which will be slate 700. And we're
294:23 going to update the opacity. Let's say it'll be 50. Okay. Then we'll have one
294:29 more div. Let's say the class name is going to be flex item centered justify
294:35 between. Okay. Now we'll have one div. So this is the left hand side. Let's say
294:42 class name flex item center and then gap of three. Now we're going to put the
294:48 avatar. So I'll just put a comment. And if you don't want to type this out,
294:53 basically you can just copy and paste from the source code. So here we'll say
294:58 give us a div. Here is the class name which is avatar and let's say online
295:04 class. Right now these classes are coming from Dais UI. Let's go ahead and
295:10 check this out pretty quickly. So we are using the version 4 and here
295:16 you can go under the components. Now you can search for the avatar component.
295:21 Okay. So this is what we are going to be using and you can see the code if you are using react in our case. Yes we are
295:29 using. So you can see like you just have the avatar class and it works out. Then
295:34 for the online status as well I think is it here? Okay. So like this is the online and offline
295:41 statuses, right? You can go here. You can see like this is the class for online and offline.
295:48 Okay. So just keep this in mind like this is where it is coming from. So I'll just scroll a little bit. Now let's try
295:55 to create an input element. Type is going to be equal to file so that we can
296:00 select files from our laptop right from our machine. And we'll say this should only accept images. So I'll say anything
296:08 that starts with image and then let's say class name. It is going to be hidden but for now let's just delete it. I'd
296:15 like to show you something. Um here I'll just give the reference. Let's say it'll be file input ref and then on change
296:24 like once we select an image what do we want to do for now? Let's just call it the empty method. So this doesn't do
296:30 anything. But now let's see the end result here. As you can tell, like this looks
296:37 really, really ugly, right? We don't really want to see it. Instead, I'm going to hide this. Okay. So, let's say
296:44 this should be hidden. Now, we don't really see it, but it is still in the UI. Basically, when we
296:51 click to this image, behind the scenes, we are going to click to this input.
296:57 Okay. So, let's see how we can make that work. I'll say button. This is something really, really common. So if you have
297:03 never seen it, you should learn it. Okay. So let's say button. I'll give some classes. And I am too lazy to type
297:10 this out. I'm just going to paste this in. Okay. Super simple. And on click,
297:16 let's say once we click to this button in the background, basically we would like to click to this input. So here,
297:23 let's say file input ref.click.
297:28 Okay. So that's why we are using the file input ref in the first place so
297:33 that we can basically click to this input when we click to the button, right? Okay. Um I think that's it. Now
297:40 we're going to put an image. Let's say the source is going to be if we have a selected image, we should see that. If
297:48 we don't, we can say get the oath user.profile pick.
297:54 If user doesn't have it then we can use the avatar.png.
297:60 So this is going to be coming from the public folder right. This is the default image. Um let's say user image. So for
298:08 the alt text we are going to say user image and let's say class name is going to be size of full and let's say object
298:15 will be cover. Okay. So we can save this. That's the image. Um now I'll put
298:20 one more thing. Maybe before that let's see the end result. Okay, so we have this. If we click to it, so when we
298:28 click to it, it's going to open up the file explorer so that we can select images.
298:34 But now what I want to do is just add a hover effect here. Let's go ahead right
298:40 below to the image. I'll have one div. And let's say the class name is going to
298:45 be absolute. And again, I'll just copy and paste so that we don't waste too much time. So super simple thing you're
298:53 going to see what this does. Let's say we'll put a span element. Last name is
298:58 going to be text of white and let's say text is going to be x small and this is just going to say
299:05 change. Now when we hover over this you would like to make it visible. So once I
299:12 hover over that you can see we have the change text right. Okay. So this is that
299:18 effect that we can get with this basic div. Now right after this we can scroll
299:24 to the bottom after the input and after this div we are going to put uh one more
299:29 div. This is going to hold the let's say username and online text.
299:37 So let's say we will have an h3. This is going to have the o user full name. And
299:44 we can give some classes like text slate of 200. Then we can say font is going to
299:51 be medium. Um I'll say text of base I think. Let's see what this does. Font
299:58 size and line height is basically going to be reseted. And then let's say
300:03 maximum width is going to be something like 180 pixels. Um and I'll say just
300:10 say uh sorry I'll just say truncate. If we go less than this width or longer
300:17 than this, uh, how would we say? Yeah, I think if it is, if the width is longer than this, it's going to truncate the
300:23 text. Um, right after the H3, I'll say P tag online and let's say class name of
300:31 text slate 400. Okay, then we're going to say text of XM
300:38 small. Let's save and take a look at the end result. Okay, so this is what we just built. Now we would like to build
300:45 the buttons. So after the P tag, after these two
300:53 divs, just go below and put a comment like buttons, then we'll have this div
300:59 with the class name being flags gap of four and items centered. Right now we
301:05 are going to put the log out button. First I'll just say logout btn and I'd
301:11 like to copy and paste this three lines of code. So this is the class name. Once
301:17 we click to it, we are going to call the log out method and it has this log out icon.
301:23 Okay. So that's the end result. Now let's try to put the sound icon or the
301:29 button I should say. Let's say sound bottle btn. Now once again I'd like to
301:36 copy and paste it. So it is like maybe five lines of code. Let me paste and I
301:42 will walk you through it. Um just save this code and I can zoom out. Okay. So
301:47 we have a button with these classes. That's the easiest part. Once you click
301:52 to it, we are going to play a sound and we are going to import this in a second.
301:58 And like I'll just walk you through it in a second. Uh I promise. Then if a sound is enabled, we are going to see
302:05 this icon. If not, we are going to see this one. Now let's try to import this
302:11 sound which is going to be coming from the public folder under the sounds. It
302:16 is going to be this mouse click. Okay. So it's this one and I have
302:21 already provided the sounds. Let's scroll to the top and just try to import it. So right below to the function I'll
302:30 say mouse click sound new audio and get it from the sounds you know just put the
302:37 exact path for this one. Okay so once you click to it basically
302:44 we would like to play it but just before we play that we would like to reset to the start so that we can have the best
302:51 effect. Um here we are also calling the toggle sound method so that we can
302:58 update this state. So let's just see too much talk. I think we we should just
303:03 save and test it out. By default this is off right. We don't have anything in the
303:10 local storage. But if I click to it now it is open. And even if I refresh since
303:16 it is in the local storage. Um okay. So, this should be actually
303:21 true. Let's see why this is the case. Do I have any typo?
303:29 Um, let's see. Is sound enabled? I'll go into the chat store.
303:36 So, is sound enabled?
303:43 So, maybe we should say something like JSON. because it might be string. Let's test
303:50 it out. I'll have it open.
303:57 Refresh. Okay, now this is working. Previously, we didn't use JSON.parse. So
304:03 that was just getting it as a string and string true is not equal to the boolean true, right? So that's how I can debug
304:10 it. All right. Now this is working correctly. Like if it is turned off, you
304:18 refresh. This is still turned off. If it is turned on, you'll leave the website
304:23 and come back again. It is still turned on because we are keeping track of it
304:28 under the local storage. So let's see
304:35 it is this one right now. It is true. Let's make it false. Okay. So I just
304:41 have to explain it in super detail because maybe you have never worked with local storage. Now everything works as
304:48 expected but the most important thing doesn't work right if we want to change our profile image. So here I'll go ahead
304:56 select something like it doesn't update the UI and it doesn't upload it to
305:02 cloudary or to our database. Let's try to fix it. We will go under the let's
305:08 say profile header. Um here once we select an image this function is going
305:13 to run because we said on change just go ahead run this method and then we can
305:19 take the event. So from the event we can get the selected file. I'll say event.target
305:26 dot file actually files this is an array we're going to get the first one. So
305:31 this is the selected image. Let's say if there is not a file just return don't do
305:36 anything. But if we have a file then we can create a file reader. So I'll say
305:42 new file reader. This is a JavaScript API that we can use. So I'll say reader
305:49 dot read as data URL and we are going to pass the image as an argument. Okay. So
305:58 this is going to allow us to display the image nicely on the UI. And then we just
306:03 need to do one simple thing. So we'll say reader onload and basically once the
306:09 image loaded we're going to have this function let's say async.
306:14 So this is the callback function that we would like to run.
306:20 Okay. So let's say we are going to get the base 64 image which is the image
306:26 format but it is in string. Okay. So our so our image will be converted into a
306:32 string. So let's say reader dot result and then we are going to say set
306:38 selected image to be equal to base 64 image. Now if you if you are using it
306:44 for the very first time I completely agree that this looks a little bit weird but this is something like pretty common
306:51 okay so you'll be using it a lot of the time so you better get used to it right if this is confusing that's good because
306:59 that means you are learning something new okay so we have the state now we would like to also uh update it to our
307:07 cloudary bucket and to be able to make that work we need to call a method that is going to call our back end. So let's
307:15 go under the oath store and try to create that method. First I will you
307:21 know just shrink this. Let's say update profile.
307:27 Let's say this will be an async method and we are going to get some data and
307:33 this data is basically going to be the profile picture that user wants to
307:38 upload. So here we'll have a try and catch block. Let's say we're going to get a response back by calling the post
307:47 method to our endpoint which is / oath slash update dash profile and let's send
307:56 the data to the back end. Okay. Now let's say set
308:01 o user with the response data and we can show some toast for the success case.
308:09 like profile updated successfully and then for the catch I'll just put the error case
308:16 just like this okay so we would like to call this method right here so I'll say await update
308:24 profile which is going to be coming from oath store um here let's say we are
308:30 going to pass the profile pick which is the base 64 image now let's test it out
308:38 so here I'll go ahead and try to upload a new image. So, this is what I just
308:43 selected. Let's say open. Okay, looks like we got an error. Let's see. It says
308:50 404 not found. What do you mean? API oath update profile. Let's see. Don't we
308:56 have this endpoint um under the routes?
309:03 Okay, so this should be put, right? That's correct. So we'll go ahead instead of post we'll say put because we
309:10 are updating something. Okay let's refresh and do it again. So I
309:15 will select the same image. Let's say open. Okay. So I think this has been uploaded.
309:22 We got the notification immediately. Um we could have a loading state I think
309:28 but I will leave it as a challenge for you. So you would go here create a state like is updating profile image right
309:37 here you would say it's going to be equal to true finally it would be false
309:42 and then here in the UI you would show some kind of indicator right I think
309:48 that's a perfect challenge for you to test it out all right so that's pretty much it for the profile header component
309:56 u even if you like refresh you're you're still going to see this image because now it is stored in your cloudary
310:03 bucket. Just go ahead under the assets you should be able to see it and then
310:08 this URL like it has a URL right it is stored under your database. So go ahead
310:14 find this user I think we are logged in as let's see it is John.
310:21 So here you can see profile picture is coming from cloudary. So this is that secure URL um that cloudary gives you.
310:28 So here is what happens behind the scenes once you upload the image. First we save it to cloudary and this has a
310:36 URL and it just get that URL and save it to the database under the profile pick.
310:42 So this is how we can display it nicely. Okay. So I hope it is not really
310:48 confusing at this point. That's it for the profile header component. Let's try
310:53 to close everything. Go under the chat page. So just go under the chat page.
310:58 We're going to get started with the active tab switch. So it's going to be a pretty basic component. It is just going
311:06 to allow us to switch these tabs. And again they are going to be coming from
311:11 Daisy UI. So they have a component called tab. Okay. So it works in this way.
311:19 Like in this example we cannot switch this I believe. But you get the point.
311:24 This is a similar kind of thing that we are going to be using. Okay. So, let's open up the source code
311:32 here. I would like to get the active tab from use chat store.
311:38 Let's say we're going to have the active tab. Let me zoom in
311:44 as well as the set active tab method. Okay. So, here in the return statement,
311:51 I'll have a class name. Let's say tabs apps boxed
311:57 background transparent and I'll say padding of two margin of two. So once
312:02 again they are coming from the documentation if you wanted to double check here we'll have a button that is
312:09 going to say chats we're going to have another one it'll say contacts. So if you click to this button let's say
312:16 on click we are going to call the set active method
312:22 and we'll just pass the chats as the argument and here I'll copy it paste it
312:29 this time this will say contacts and if you take a look at this method
312:35 under the chat store like this is what we are doing right so set active tab
312:42 wants you to pass a tab and and it's going to set it with our state
312:48 and this is exactly what we are passing and then we're going to pass some classes. Now let's say instead of typing
312:55 this out I'll provide this. So it'll always take the tab class but if it is
313:02 active it is going to take this background with this text so that um so
313:08 that we can highlight it in this way but else it would take these classes.
313:13 So this is exactly what we are doing. Let's save and we're going to do the exact same thing for this one.
313:23 Okay. So, this is just going to highlight that if it is selected. Now, let's save and test it out.
313:31 Um, both of them are selected. Let's just refresh. Okay. So, I think this
313:36 should be equal to contacts. We just copied and paste it. I forgot to update it. Okay. Now, this is active. If
313:44 you click to this one, it is active. UI updates. So, everything works as expected. So just pause the video and
313:51 take a look at this file. I think you will understand everything. All right. Now that we are done with this component
313:58 as well in the sidebar, we just left two more components. Let's try to build them
314:03 pretty quickly because they're going to be easier than what you think. Let's get started with the chats list. So first I
314:10 will create two different components. One for the loading state. So I'll say users loading
314:19 skeleton jsx. And this is something that I'll copy and paste from uh source code
314:26 because it doesn't have any logic at all. It is just 20 lines of code. And let me show you like how this will look
314:34 like. Okay. So just wait couple of minutes. Copy and paste this from the source code. We are going to see it and
314:40 then I can explain the code in a couple of minutes. Okay. So once again, super simple, just UI. You can just copy and
314:48 paste. Then the other component is going to be I think something like no chats
314:55 found. JSX. And again, you can find this from the source code. Just copy and paste 30
315:03 lines of code. I promise I'll just walk you through it. Okay. So for now, let's go under the chats list and try to build
315:10 this component. First I will import the let's say chat store and then I'll get
315:18 the use effect. So basically we would like to call this method get my chats.
315:25 Is this what we have? So we said get my chat partners
315:30 and then we have the chats the loading state and then the uh setter method.
315:36 Okay. So under a use effect I'm going to call this method right. So let's say use
315:42 effect. So this is something that we have done in the past. That's why I'd like to just be fast
315:49 and we're going to pass this right here. So it's going to call this method to get the chat partners. And let's say if we
315:56 are in the loading state, we can just return that skeleton. I'll say users
316:02 loading skeleton and I'll say if use sorry if chats.length length is
316:10 equal to zero then we can say return no chats found component
316:17 okay so let's see I'll just make this to be true so that we can see the UI
316:22 okay so this is the skeleton like kind of like loading state since we have this
316:28 class called animate pulse it is going to have this pulsing effect right it
316:34 just fades in and fades out and we have a circle a long div and then a like smaller diff
316:42 right so this is how we can make that work just take a look at this like this is
316:48 the circle I don't know how to explain it sorry like this is the circle this is the longest div
316:56 it is this one and then we have that one okay so I hope you are happy with this
317:03 code we have like three different times going through these items
317:09 Let's bring this back and let's make this one true so that we can see this
317:14 component. Okay, so this is what you have under here. The exact same content. Once you
317:23 click to this, it's going to take you to the contacts because we just say set
317:28 active tab on click to be the contacts. Okay,
317:34 I hope that you're happy with this code. Now we'll go under the return
317:41 like return something. For now it's going to be a fragment. I'll just say get the chats map through it. For every
317:48 single chat we are going to return some kind of a UI. So here we'll have a div.
317:54 Let me zoom in. Okay. This dev is going to have the key.
317:60 Let's say chat ID. Then we can give some classes. At this point, I'll copy and
318:07 paste. Okay. Then on click, we will say this should be the selected user. Just
318:14 pass the chat into it. Then we are going to put one div like it is five lines of
318:19 code. Let me walk you through it. We have the avatar with the chat profile pick. If this is null, we're going to
318:26 put the default and then the username. Okay, so let's save and test it out
318:32 under the chats. Okay, looks like we have a chat because this is the one that
318:37 we created in the previous sections. So we have some messages between John and
318:45 this user. So we can see it here, right? So this is the avatar the username. Now
318:50 we always have this state as online. It is coming from here. But we are going
318:55 to make this to work actually from the um from the scikit server. So I'll say
319:01 to-do fix this one line status
319:07 and make it work with socket. So this is for later sections but yeah
319:14 other than this I think that's the entire component. Again super simple we are just calling our method to get the
319:20 chat partners because we are under the chat list component. We have the alerting state, not found state, and
319:28 we're just displaying every single chat chat partner that we have. So, you can
319:33 copy the entire component and paste it under the contact list and just update
319:38 the state with it. So, maybe you can pause the video and do it as a challenge. It'll be the exact same
319:44 thing. Instead, you are going to fetch all the contacts, all the contact list in the database. Now, let's go ahead and
319:51 do it together. Right? So here I will import a couple of different things. So from the chat store we will get all
319:58 these things that you can see basically the method to fetch the context this
320:04 state setter method and the loading state. Let's import the use effect call the method and here is what we have for
320:10 the loading state. And for the you know for the return statement I'll basically
320:16 copy and paste it. It is the exact same thing. There is no need to type this out. We are going to map through it. For
320:23 every single contact, um we will basically return a div with the image
320:28 and full name. If you clicked it, it would be it would be the selected user.
320:34 Okay, let's save and give it a go. Looks like we have this import.
320:43 Let's say import this. Okay, now these are all the users that
320:49 we have in the database other than us. So we have Jane, this user and Bob. And
320:55 if you try to click one of them, this should update. Okay, so it shows us the
321:00 chat container. So I hope it wasn't really annoying because I just copied and pasted a bit of code in this
321:07 section. But these are the things that we have done so far like multiple times and we are I think 5 hours in. It should
321:14 be fine to copy and paste a little bit of code. Again, we can add a to-do.
321:20 Let's say make it work with socket later in the video. Okay. So, with this, we
321:27 just completed the sidebar on the chat page. In the next section, we can build
321:32 the chat container where we have um the messaging functionality. For now, I'll
321:38 open up the status bar and create a new branch.
321:44 Okay, let's say um sidebar
321:50 and go right here. Stage all the changes. Let's say sidebar completed.
321:57 Commit. Publish the branch.
322:03 Let's go into the source code and create the pull request.
322:08 And as usual, I'll just wait for the suggestions just to check if we have any
322:14 potential issues or not and then we can merge the pull request. So here are all
322:19 the features that we have included basically the entire left hand side right um here. Let's go ahead and see if
322:27 we have any suggestions. So you can take a look at the sequence diagram. I think
322:32 I'll just skip this at this point. We are 5 hours in. Let's not waste any time. So, here we have a suggestion that
322:40 says you could create a variable. I think this is like super niche. We don't really need to do it. I don't think so.
322:47 Let's scroll to the bottom. Okay. It says you can create another ref, but ours is is also working without any
322:55 issues. So, I'm going to skip that. Here we have a potential issue. It says you
323:01 should probably optionally change this. Well, that's correct. We could do it. Um
323:06 I'll just leave it for the upcoming sections. Basically here we would like to let's go into the chat store.
323:14 So you know if one of them is like undefined getting the other thing is going to break the code. So you would
323:21 like to put these question marks right? Optional chaining. This is what we call
323:26 it. But for now I'm going to skip that. Um we have the same thing here. Other
323:32 than this, we don't really have any issues in our codebase. So, I'm going to merge this.
323:39 Once this is done, we can go into the master and sync this up.
323:52 Okay. So, I think our codebase is up to date now, right? We have everything.
324:00 Okay. So it is just working as expected. We can end this section right here. And
324:06 by the way, you can take a look at the live application every single time. So
324:11 it is actually working like this is not on localhost, but it is just deployed
324:16 application, right? So let's try to log in. Uh this time we can log in as I
324:23 think Jane, right? So let's say Jane under the login of course say
324:29 janeo@gmail.com let's put the wrong password
324:34 we have loading state invalid okay now let's put the correct one
324:40 okay so we just logged in um for some reason
324:47 wait why we couldn't see the latest version
324:53 okay so I think it was in the cache. Now, if you refresh, you're going to get the latest changes in production.
325:01 Okay, so that's going to be it for this section. Hopefully, in the next one, we can build the chat container. So, I'll
325:07 see you there. Now, it is time to get started with the chat container component, which is going
325:13 to be under the chat page. So, we're going to get into this, but first, let's build this placeholder that is going to
325:20 look like this one. Okay. So if there is no chat selected, we are going to display this. We'll just say select a
325:27 conversation. So as you can tell there is no logic at all. It is just a UI like
325:32 we have one icon, one title, and then one P tag. Right? So instead of typing
325:37 this out, I'll go ahead and grab this from the source code. You can do the same thing. Go under the components,
325:44 find this file, and just copy the content, paste this in. It is like 10 lines of code. Okay, so we got one icon,
325:52 one title, and the text. Okay, let's save and test it out. If there is no
325:59 chat selected, this is what you're going to see. But if you click to one of them, you're going to see the chat container
326:05 that is going to be looking like this. So we are going to have the header component, message history, and then one
326:13 input where we can send text or image or both of them at the same time. Okay, so
326:20 let's go ahead and get started with UI. But again, just before we get into it, we would like to build some
326:26 functionalities under the chat store so that we can basically fetch the
326:31 messages. So here I will shrink every single of these functions
326:37 so that it is not really confusing. Um let's try to build the method. So I'll
326:42 say something like get messages and let's actually say get messages by user
326:48 ID as the AI suggest us. So we are going to pass the user ID which is going to be
326:54 like whatever user that you click. If you click to this one, this would be the user ID that you would send. If you
327:01 click to this one, it would be this user's ID. So you get the point. Okay. So you can pause the video and actually
327:08 test it out. At this point, you should be able to build it by yourself just by
327:13 looking at these functions. So, first we would like to update the alerting state for messages. Then we'll just send a get
327:20 request to our endpoint. Okay. So, I'll say set is messages loading is equal to
327:26 true. Right? Then try catch and finally blocks. Here under the try we'll say
327:33 const response and let's say axios instance get here is our endpoint um and
327:39 then we'll just say set the messages array is going to be
327:45 whatever we have in the database okay now for the catch we can just say toast dot error and here we can do optional
327:53 chaining and we can say if this is undefined for some reason we could do something like
328:01 let's say something went wrong. Okay. And in the finally we would like to set
328:06 the loading state to be equal to false. So that's the entire method. Okay. So get messages by user ID. We are just
328:14 updating this state. Now let's go into the chat page under the chat container
328:20 and get started with this component. So first I'd like to get the chat store
328:27 because from here we will get couple of different values. So I'll get the selected user. I'll get the get messages
328:36 method which is this one. Okay. So I'll just copy the name. Get messages by user
328:42 ID. Let's get the messages array. Um I think that's it for now. Later in the
328:48 video, we'll add more things, but for now, uh, let's get the oath user as well. You're going to see why. And let's
328:56 import this one as well. Okay. Now, I'll just have a use effect so that we can
329:01 call our method here. I'll just say let's call the get
329:06 messages by user ID. And we are going to pass the selected users ID. Okay. So,
329:12 just put underscore ID. um here let's say if selected user updates
329:18 as well as the method okay so whenever this change this method is going to run
329:23 again and then we can jump into the return statement let me give I'll put space here I'd like to return an empty
329:31 fragment um here I'll have a chat header component so first let's try to build it
329:37 then we're going to build the rest of the component I'll copy this name go under the
329:44 components create that and let's try to import it
329:49 in this file then we can build it so I'll just go ahead visit this file I think this will be around 30 lines of
329:56 code so let's try to get the selected user and the method from our hook so
330:02 you're going to see why we are getting the state as well as the setter method um and then I think we can just have the
330:09 return statement so here I'll have a class name with the flex justify between
330:15 item centered. Now if you're wondering why this is justify between you can take a look at the end result from the
330:22 diagrams. So we have something on the left something on the right and we have
330:27 some between gap right. So justify is between so that they are spaced out.
330:33 Okay. So say items centered. We can say background is going to be slight 800.
330:39 And I'm going to update the opacity. I'll just say 50. Then let's say border
330:45 dashb. Let's give a bit space. Then I can say the border color is going to be
330:51 slate 700. Let's say 50% opacity. Then maximum
330:57 height is going to be something like 84. Let's say 84 pixels. Hitting x of six.
331:05 And let's say flex of one. Okay. Now let's save. get into the uh get into the
331:11 div I'll have another div. Let me just copy and paste the content like it is
331:17 going to be sorry the classes. So flex item center and we will give gap between
331:23 the X X direction. Then I'll have one div let's say class name is going to be
331:29 avatar. Let's say it will be online. Later in the video we will make this to be dynamic once we have the online
331:36 users. Um then I'll have one more div. This will have the image. Let's say
331:41 source is going to be selected user.p profofile pick. If this is undefined we
331:47 can put uh the avatar placeholder right and I think for the alt we can just give
331:55 the selected user dot full name for the classes width 12 and rounded
332:03 full so that it is a circle say rounded dash full.
332:08 Okay. So let's just save and see the output. So if you select a user, you will see
332:15 the header component. Right? Let's keep building. Now we need to get the full name. So go under the image under one
332:24 div and two divs. We will create one more div. It is not going to have any class names. Let's say h3. And we will
332:32 have a p tag. Okay. So here I'll say class name text
332:38 slide of 200. Then I'll have font medium.
332:44 For the content we're going to put the full name. And then here for the P tag I'll just
332:50 say for now online. Um let's say class name text slate 400.
332:59 And then I think I'll just say text small. Okay. So that's it. Now let's go outside of these two divs. At the very
333:06 end, we'll just put a button which is going to be the close button. So I'll say X icon is going to be the content
333:13 which will look like this. And let me just give you some class
333:19 names. So here are the classes that I just copied and pasted. This change the text and hover state as well as the
333:26 size. Now when we click to this button we would like to say now let's say on
333:31 click basically we would like to set the selected user to be null. Okay so it
333:36 should be looking like this. Let's test it out. This user is selected. If I
333:42 click to it now selected user is null. Let's test it out with this one. Now it
333:47 is Jane this user and this one. Now one more optimization that we could add is
333:54 if we if we press to the escape keyword it should like close uh it should make
333:59 the selected user to be null right so let's try to implement that I'll go under the chat header component let's
334:06 have a use effect let's initialize it first
334:12 okay so here I'll say window do add event listener let's say key down and
334:18 we're going to call it handle escape shape let's say key and this is a function
334:24 that we can create let's say const it'll be super simple let's say we will get
334:30 the event let's say this is an arrow function by the way okay so I'll just say if event
334:38 key is equal to escape then what do we want to do is basically reset the state
334:45 right so I'll say set selected user to be null Just to make this a little bit
334:51 more performant, I'll add the cleanup method. Cleanup function. Let's say return
334:58 window dot remove event listener. And we'll pass the same thing. Okay. Now
335:03 let's say if selected user. Okay. So basically it says uh you are
335:10 using some dependency you should add it into this array which is this one.
335:16 Okay. So let's save and test it out. I'll select one user and I'll press escape. As you can tell, state is just
335:23 getting resetted. So this is one optimization that you can add and your users would thank you for this. Okay. So
335:32 I think that's the entire chat header component. I'll delete this empty space
335:39 and we can get started with the next component right here under the chat container. So let's go under the chat
335:46 header and have a div. I'll give the classes let's say flex of one heading of
335:53 let's say petting x of six or over or over or over or over or over or over or over or over or over or over or overflow y auto petting y of 8. So we are going
335:59 to display all the messages. So I'll say if messages.length is greater than zero in this case we
336:07 would like to run this part else we're going to run something else. So this part here I'll say no chat history
336:16 placeholder. So this is a component that we can build right now. Under the
336:22 components I'll just paste this in. So find the source code then find this
336:28 file under the components just get the content. It doesn't have like it doesn't
336:33 have any logic just UI. Uh one thing that I'd like to pass is the username.
336:39 So I'll say pass the name as a prop and I think this is kind of annoying for now. Let's just say return a p tag.
336:47 Let's say some messages. Okay. So we're going to pass a prop called name and we can say selected user
336:55 full name. You are going to see why. Just save this. Go here again. Get this
337:01 code from source code. So we are getting the name and we'll we'll say something
337:07 like start your conversation with whatever the name is. Okay. So let's save, import it and see the end result.
337:17 If I click to this chat here we can see it says you don't have any conversation with this user right go ahead and start
337:25 it. So this is the component that we just pasted. But if we have some messages
337:31 we are going to see some messages. Okay. So, it's going to look like this. Of course, if message is sent from us,
337:38 we're going to see it right here on the right hand side. But if it is from the other user, we will have it on the left
337:45 hand side. So, how can we build this? Well, we are using the UI and they have
337:50 a component for this. So, under the version 4, let's say components, they
337:55 have chatb component which look look like this. Okay. So we are going to use
338:01 either on the right hand side or on the left hand side. And if you take a look at the code, they have chat end and chat
338:09 start. So if we if we send it, we will use chat end. Okay. So let's see how we
338:16 can build it. I will go under this P tag. Of course, we are going to update it. This is not
338:23 going to be a P tag. Let's delete it. It'll be a div.
338:29 Let's turn this off or close this off here. I'll pass the key. Let's say
338:35 okay. So I think I just did a mistake. This is not going to get key. So let's delete the key. This will have the class
338:42 name. So let's say maximum width of 3x large. Then we're going to put MX auto
338:48 so that it is centered. Say MX auto and space Y of six. Let me kill the AI by
338:55 the way. Okay. So within this we will get the
339:01 messages. Let's say messages do map for every single message. Oops. Let's say
339:07 give me each message. And I would like to return something which is going to be a div
339:14 and it'll have the key. Let's say message id. Then we can give the class name.
339:21 This is going to be dynamic. So let's open up the back tags. I will
339:26 say this is always going to get the chat class but we would like to deter like
339:31 determine if it is going to get chat end or chat start and for this I'll say
339:37 something like if message sender is me then it's going to be chat end but else
339:43 it's going to be chat start I hope that makes sense now we are going to have one more div with some classes again this is
339:51 going to be dynamic so here I'll open up the pack tags let's say open up the back
339:57 text. We will have chat dashbubble. We will always have this class as well
340:03 as the relative. But then we would like to do something dynamic which is going to be related to background color. So if
340:11 we send it, it's going to be in this background as well as I'm sorry if if we
340:17 send it, it is this background. If other users send it, it'll be this background. So let's go ahead and add this class
340:24 again. I'll just copy and paste it. If message sender is us, this is the
340:30 background, but else it is this one. And then for the message content, we have
340:35 two different options. It could be either a text or an image. Right? So
340:41 here I'll say if message has an image, display the image and if message has
340:47 text, display the text. Now if we have both of them, we are going to see both of them at the same time. It is not a
340:53 problem, right? Okay. So now let's just save and take a look at the end result.
341:00 Okay. So here we can see this user send us two different messages.
341:05 And this one has nothing but we can fetch the messages for this user. And on
341:11 top of this we can add the message created at time. Right? So I'll go ahead
341:16 and I'll say create a new date with this created at right and just format this
341:22 output. So let's save and take a look at the end result. Here we can see this is when we sent the message. So we use the
341:30 timestamps in our message model. Let's take a look at it.
341:35 So thanks to this now we are able to access to the created ad field. And that's the entire component. Now let's
341:42 scroll to the bottom just before this fragment I will have a component called
341:47 message input and let's try to create it
341:52 under the components
341:58 and I'll just import it. Okay. So let's take a look at the end result. We have the message input. So we
342:06 are going to build this in the next section that is going to look like this. And it is going to allow us to send
342:12 images I mean send messages. And just before we end this section I'd like to
342:18 add a loading state. So here if I click to this one we should see some loading
342:23 states before we fetch the messages. Right? So let's do it. Here we already have our state called uh is messages
342:31 loading. So let's copy this name and import it. So here I'll say if messages
342:39 length is greater than zero and if we are not in the loading state right so if
342:47 we are not in the loading state okay go ahead show the messages and just before
342:52 we say no placeholder right no chat history placeholder here I'll say if is
342:59 messages loading then we would like to return something but if we are not in the loading state then you can return
343:06 this part, right? So, let's say if this is the case, we can just have message uh
343:12 let's say something like messages loading skeleton
343:18 will display this component. So, I know that this might look a little bit weird. Basically, we got the loading state. We
343:25 say if we have some messages and if we are not in the loading state, okay, then you can display the messages. But if we
343:33 are in the loading state, display the messages. If not, go ahead show the
343:39 placeholder. Okay. So let's copy this name, create it under the components
343:46 say.jsx. You can find this under the source code. Just go ahead, copy the code and paste
343:53 this in. So it is 10 lines of code where we have some let's say skeletons. So, I'm going
344:00 to save this and import it and let's see the end result.
344:07 Okay. So, here if I click to one of these chats, we're going to see the loading state for a split second until
344:14 we fetch the messages. So, let's do the same thing again and again. Okay. So, I
344:20 hope that makes sense. You can just take a look at the source code. Uh, pause the video. I think you will understand what
344:27 is happening here. So with this we can end this section right here. I'll close everything. In
344:34 the next section we are going to build the message input. For now let's create a new branch. Here I'll say something
344:40 like chat container setup
344:46 or what should we say like chat container. Um I don't really know. Let's just say
344:51 chat container setup. I think this should be fine.
344:57 add our changes. Let's say chat container setup. Done. Commit. Publish it.
345:07 And under the source code, let's go ahead create the pull request.
345:15 And I'll just wait for the reviews from code rabbit. So here are all the
345:20 features that we have introduced in this section. You can pause the video and read it if you would like to get a quick
345:26 summary. Then you can take a look at these files as well as the sequence diagram. Then we can take a look at the
345:33 code suggestions. So here it says you should add an if statement to the chat
345:39 container under the use effect. So let's pretty quickly see it under the chat
345:44 page. So we have chat container. Now, we don't really need to add an if statement
345:50 for the selected user because if we don't have selected user, we are not
345:55 going to see it in the first place. If this is null, if this is null, we're going to see this component. So, for
346:01 that reason, I'm going to skip this. Again, if you wanted to, you can add this if statement, but it is not really
346:08 important in this case. And here it says instead of doing doing this, you can
346:13 sort them, but I think we don't need to. messages are already in the sorted order. This is how MongoDB sends us. So,
346:22 I'll skip this. Here it says you can make this a little bit more clean. Again, I think this is working fine. I'm
346:29 going to skip this. Um, under the chat header, the same
346:34 suggestion. We don't really need it. For the class name, again, we can just skip
346:40 those. Same for this method. like it says if this is undefined, right? If
346:46 this is null, just go ahead and handle it differently. But I'm going to skip that. We don't really need it. Okay. So,
346:54 let's say merge the pull request. Confirm. Once this is done, we can
347:00 basically switch to the master and let's try to get the latest changes.
347:08 So we'll say sync this up. Now our code base is up to date.
347:17 Okay. So with this in the next section we are going to build the message input where we can send messages. So I'll see
347:24 you there. Now it is time to get started with the message input component. So let's go
347:31 into it. And it's going to look like this. At the end, we are going to have one input, one button to be able to
347:38 upload the images and one so that we can send the message. Okay, so let's get
347:44 started with it. The first thing that I'd like to do is creating a hook. So
347:49 under the front end, under the source, I will create a hooks folder. And within
347:54 this, I will create a custom hook called use keyboard sound.js.
348:02 So this hook is going to allow us to play a random sound when we press a key.
348:08 And these sounds are going to be one of these. Okay. So we will randomly select one of them. Now let me shrink the left
348:14 hand side. Let's try to first set up our audio. Okay. So we have keystroke
348:20 sounds. It is an array of um audios. Okay. So we're just importing them and
348:26 we are going to select them randomly. So let's create our hook. Let's say use
348:31 keyboard sound and within this I'll say const play
348:38 random key stroke sound. So this is our
348:44 function and let's say it'll be an arrow function. Okay. So we'll get into the content in a
348:50 second but basically at the end of the day we would like to return this function out of this hook. So, let's
348:56 copy the name, paste this in, and let's say export default
349:02 this hook. Okay, so we're going to go ahead here just call our hook. So, I'm too lazy to
349:09 type this out. Let's try to import it. And this is going to give us the
349:16 function. Okay, so we'll just dstructure this. And we're going to be using it
349:21 whenever we press to a key. Now let's try to build the logic. It is actually
349:26 easier than what you think. So we would like to select one item randomly. And
349:32 here is how we can do it. We'll say go into this array and randomly select one
349:38 of them. So this is the random sound. And we would like to play it. So I'll say random sound.play. So that's
349:44 actually it. But I'd like to optimize it a bit. I'll just say under the catch if we got some errors basically I would
349:52 like to just console log it to debug it. I'll say audio play failed and let's
349:59 just put the error. Now one more optimization you would like to say r uh
350:04 random sound dot current time is equal to zero. And I will show you
350:10 why this is the case. So here I'll say this is for a better user experience.
350:18 Definitely add this. And later in the video I'm going to delete this line and
350:24 show you what happens if we don't add this reset. Okay. Okay. So I think
350:29 that's the entire thing. We can save and get into the component. So we are going to have couple of different states. The
350:36 first one is to store the text, right? the message text and then user can
350:41 select an image. We would like to show the preview before they send the image and then we will have an input ref. You
350:49 might be asking why then we can go into the chat header component. So this is
350:54 what we have done I believe when we okay so not chat header sorry let's say
351:00 profile header component so we had the file input ref and we are using this so
351:06 that when we click to the button behind the scenes we are going to click to this input element so it is the same thing
351:13 when we click to this icon behind the scenes we are going to call an input
351:19 element so that's why we are using this ref let's give a bit space okay then we
351:26 can get the chat store import it from here we would like to get our method
351:33 which is to send a message as well as is sound enabled state now I think we don't
351:41 have this method so I'll copy the name save this file and let's try to create
351:46 it under our store okay so let's scroll to the bottom.
351:53 Paste this in. This will be an async function that we are going to create now. So if user wants to send a message,
352:01 they should send us the message data. Right? This is going to have the text as
352:06 well as the image. And then we can get into the try and catch block. Now under the try, we would like to say give me a
352:14 response axio instance.post. And we're going to put our endpoint
352:19 which was slash messages slash send and then the user ID. So if you want to send
352:26 a message to this user, we need to send their ids, right? And this is the
352:32 selected user ID actually. So whichever user selected, we are going to send their ID to the endpoint. So let's say
352:40 this is going to be selected user dot ID. But how do we access to this
352:47 selected user uh state? So it is right here under this under this hook. We can
352:54 call the get method so that we can fetch this value here. I'll say con dstructure
353:00 something and then we can call the get method call
353:06 this. So we'll just get the selected user field. Okay. So now we can access
353:12 to that value. So that's the end point. We would like to send the message data.
353:18 Okay. So that's our entire call. Then we can say something like just update our
353:24 messages state. Let's say messages. Now this is going to be equal to let's say
353:31 messages dot concat. We're going to concatenate
353:38 it with the res data. So again we would like to get access to the messages
353:45 because we would like to get the like all the previous messages and on top of it we are going to add the latest
353:51 message. Let's say messages. Okay. And then in the catch we could
353:58 basically show a error with the toast. Here I'll say error dot response
354:06 dot data dot message. And let's optional change this.
354:13 And I'll just add a fallback like something
354:18 went wrong. Okay. So that's the entire method. Basically, we are going to get these
354:24 states that we have above because we will be using them and this is how we can access it. I think we have seen this
354:31 in the past as well with the get method. we are going to send like pass our
354:36 endpoint with a post request and we're going to pass the message data and then
354:42 we would like to update the state. So basically the latest message will be added uh it'll be added to the end.
354:51 Okay, so that's the entire method and we're going to be using it in this component. And just before we build the
354:57 UI, let's create all of our functions so that we can have an easier time in the
355:02 next couple of minutes. So first we'll we are going to have a method called handle send message. This is going to
355:10 get the event and this is basically the submit form. First we would like to say
355:17 event.prevent default so that it doesn't refresh the page.
355:22 Right after this, I'll say if there is not a text and let's even trim this down. And let's say if there is not an
355:31 image preview. So if user didn't select an image or if there is no text, we'd
355:36 like to just return and we don't we don't want to do anything. And then I'll say if sound is enabled, if is sound
355:44 enabled, I'd like to just play a random keystroke sound. And then I'll have the
355:51 send message method. Let's call this. We're going to pass the text which is
355:57 text.trim. This will get rid of all the spaces that
356:03 we don't really need. So if user sends a message like hey and 10 different
356:08 spaces, we would like to basically trim this down. So this is what we are doing.
356:14 And then we're going to pass the image which is the image preview. Okay. So
356:19 this is going to actually do the uh do the magic but we would like to reset the
356:25 UI. So once you send the message let's say you type something once you send it we would like to reset this state. So
356:32 let's go ahead say set text will be reset it. And let's do the same thing
356:37 for set image preview. Okay. Finally, I'll say if there is file
356:43 input ref.curren, we would like to say this should be equal to
356:50 null as well, right? I'll say file input ref dot current dot value.
356:57 It'll be reseted. Okay, so that's the entire method. Pretty simple. We just prevent the
357:03 default, check for these, send the message and reset the reset the state.
357:09 Then one more function where we can basically upload an image. I'll say con
357:15 handle image change and this is going to be pretty similar to this one that we
357:22 have created in the profile header component. So here actually I'll just copy and paste it from the source code.
357:28 It is five lines of code. If the selected file is not an image we are going to throw an error with the toast
357:35 and we'll just return out of this method. But else we will basically create a file reader and then update our
357:42 state with the result. Okay. So one more function. So one more function and this
357:48 is the last one I promise. Let's say remove image. Let's say this is going to
357:54 be an arrow function. Basically once user selected an image we're going to see a preview here and there will be
358:01 like X button. If they click to it we are going to remove the image. So this
358:06 is that function. Let's say set image preview to be equal to null. And again
358:12 we can copy this paste this in so that we can get rid of this value as well.
358:18 Okay. So that's the entire function like three different functions that we're going to be using. Let's get into the
358:24 return statement. We will have a div with some classes. Let's close this.
358:32 And within this div we will have couple of different more. First I'll say if we have an image preview if there is an
358:39 image selected we can basically display it. And let me copy and paste it. It is
358:45 just UI no logic at all. So this is what I just pasted. You know some classes
358:51 display the image with these styling and an X icon. Okay. If you click it we will
358:58 basically remove the image from this state. Let's actually test it out.
359:06 So I think do I need to log in? Let's do it pretty quickly. Say john dogmail.com.
359:12 So I just logged in. If we click to it. Now we cannot really see anything because we cannot select the image. So
359:19 for now let's keep going. I'll just shrink this code. Let's go right below to this. We are going to have a form.
359:26 And this is not going to have any actions. But on submit we would like to call the handle send message method. And
359:33 then I'd like to give some classes like maximum width of 3x large and then MX
359:40 auto flex and some spacing. Then I'll get an input. This is going to be type
359:46 of text. We're going to put we're going to pass the value which is the text state. And on change we're going to do
359:54 something. Let's say on change create this function get the event and here
359:59 I'll say basically set the text with e.target target do value. Then we would
360:06 like to say if sound is enabled, we will basically play a random keystroke sound.
360:14 Then let me give some classes as well as a placeholder.
360:19 So I'll say type your message as the placeholder. Then I will have one more
360:24 input. This is going to be for the file and it's going to be hidden. Once we
360:30 select an image, this function is going to run. So just keep this in mind. Let's see how we can add this button. This
360:39 one. So let's go into the VS code. Right after this input, I'll basically paste
360:44 this in. So we have type of button. Once you click to it, it's going to behind
360:50 the scenes click to this input. Here are some classes. If if an image is
360:55 selected, this is going to be the text color. And this is the image icon that we are using. Let's import it from Lucid
361:02 React. Okay. So, I'm going to save this and actually test it out.
361:09 Okay. So, first I'll just send a text message like, "Hey, how's it going?" Or
361:16 let's just say, "Hey, I'm doing great." Because I said, "How's it going?" Sent
361:22 the message. Here we go. Okay, it's been sent. If you press enter, it's going to submit it because this is under a form.
361:30 Now let's try to select an image. So I just selected this one. Let's say open.
361:36 Okay, this crashed. Let's see. Image icon is not defined. X icon is not
361:41 defined. So let's go ahead get the X icon.
361:49 Now let's select it again. So I will get this once again. Okay. So, this is the
361:55 image preview. If you click to it, it has been deleted. Let's select it again.
362:01 I'll get this one. And we can add a caption. Like this is the caption. Send
362:08 the image. Um, it says something went wrong. So, let's see.
362:15 What do you mean we have course error? So, let's take a look at the terminal under the back end. It says the request
362:23 is too large, right? The payload is too large because the image is you know the
362:29 size is big. So we can go under the server.js and fix this. So this is
362:34 something that I have like I have explained in the in the backend part I said I will show you the error and this
362:42 is the error payload is too large and let's see how we can fix it. we will basically say the limit that is coming
362:49 from the front end could be let's say up to 5 mgabytes. Okay. So let's save this
362:56 and test it out once again. I'll select the exact same image which is this one.
363:01 Let's say open. This is login page or let's say this is
363:07 caption. Send the image. So we have I think a loading state why
363:14 we couldn't see it. Okay. So it took a little bit of time. Um once it is once
363:19 it is uploaded to cloudary we can see it right here. It is coming from the database. Now we would like to get rid
363:27 of this loading state because it takes too long. Right? So as soon as I press enter I'd like to see the message
363:33 immediately. And this is what we call the optimistic updates and we are going
363:40 to implement it in a second. So just keep that in mind. We would like to get rid of this error once I mean so just
363:47 keep that in mind. We would like to get rid of this effect where we have a loading. So once I sent the message or
363:54 one or two seconds, we need to wait until we can see the message right here.
363:59 So this is something that we're going to build. But first, let's put the send button into the UI.
364:06 So right after this button, we will have another one. You can copy this from the
364:12 source code. So just go under the form right after this button. This is what
364:17 I'll have copy and paste a bit of too much classes but that's fine. This is
364:22 the submit button. Let's import the send icon and just give it a go.
364:30 Let's say send from the button. Once I click it, okay, message has been
364:37 sent. And if you don't have any content, it is disabled. So you cannot click to it. All right. Now let's try to add the
364:45 optimistic updates. So once again once we send the message immediately we would
364:50 like to see it on the UI. So here we'll go under the chat store. Currently once
364:56 we send the message we need to wait until we get a response and then we are updating UI but we would like to update
365:03 it even before we call the backend method right the backend endpoint. So
365:09 here we will first get the authenticated user state which is going to be coming
365:14 from here. So how do you access to a different store value in a different
365:20 store. So you can say use oath store call this and then just say get state.
365:28 So we are going to call this method. Then here let's go ahead say const. Now
365:33 we can get any of the values. So I will get the oath user state say oath user.
365:41 Okay. So with zand this is how we can access to different values in a different store. So first I will create
365:49 a temporary ID. Let's say const give a bit space temp ID. Let's make it
365:57 with back tix. I'll say something like temp dash and let's do date.now.
366:09 Okay. So you're going to see why. Now we would like to create an optimistic message.
366:18 Okay. So we will have the underscore id. Now here this is as if we are creating a
366:25 mockup message in our database. So we'll say temp ID. Um here the sender id is
366:33 going to be oath user id then the receiver id will be selected
366:39 user id right from the selected user then the
366:44 text message it is going to be coming from message data let's do the same
366:50 thing for the image created at and one optional field is optimistic so this is
366:57 optional if you wanted to you and add it or you don't. So let me say optional.
367:05 Okay. So we have this state I mean we have this object before we send the
367:10 request we would like to update the UI immediately. So I'll just say set
367:16 have the messages state to be get all the messages right and on
367:22 top of them add the optimistic message. Let me add a comment. Immediately update
367:30 the UI by adding the message. Okay. So, let's save and
367:36 take a look at the end result here. I'll just send a message like 1 2
367:41 3. As soon as I press to it, like we can see it. It is in the UI. And now let's
367:48 do it once again with a different user. I'll just say ABC. Once I send it, it is
367:54 right here. Now, what happens if it fails? We already see it in the UI. We can remove it, right? So, here I'll go
368:01 under the catch. We'll say if it fails, we will just say set the messages state
368:09 to be just previous state, right? To the messages.
368:15 So, without concatenating it, right? So, I hope that makes sense. Let's see like
368:20 we will basically get rid of the optimistic message. Okay. So we can test it out
368:29 here. I'll say but how can we fail? I forgot. Let's say send 1 2 3 end point
368:34 is wrong. Now this is going to fail. I'll say failed message
368:41 first. we can see it and then once it is wrong like it it is just going to get
368:46 rid of like it'll just be gone from the UI once again let's do it once again
368:51 it's going to fail then it is not in the UI so this is what we call the optimistic updates something really
368:58 really important this is the kind of functionality that you would like to always implement in your chat
369:04 application so absolutely important that you have to learn and hopefully you just
369:10 learned it in this in this tutorial. All right. So, I'll go ahead and just add a comment. If you're reading the source
369:16 code, you can see what we are doing. Basically, we are removing the optimistic message on failure. Now, one
369:22 more thing that you might be wondering is that when we send a message
369:28 like do we have to scroll uh automatically like do we have to scroll manually? Um let's try to fix it. First,
369:36 I will get rid of this error that we have under the chat store.
369:41 Okay, so the end point is correct. But now let's make it in a way that it scrolls automatically, right? It doesn't
369:48 stay here. We will create a use effect under the chat container component.
369:56 Let's say chat container because this is the one where we have all the messages,
370:01 right? So after all these messages, I will put a div. It is not going to have
370:08 any content. So let's make it self-closed and we will say this will be the reference to the message and ref. So
370:17 we will scroll to this every single time. Let's create that reference. We'll
370:22 say const message ref use ref.
370:28 Initially it could be a null value and basically with a use effect we can
370:33 scroll to it automatically. So I would like to copy and paste five lines of
370:39 code. So we have use effect. We will say if we have this reference just go ahead
370:45 scroll into view and make the behavior to be smooth and whenever the messages
370:51 updates go ahead run this again and again so that we are always scrolling to the very latest message. So, let's see.
370:60 I'll just kill this. Open this up. Like, it is scrolling immediately. And let's
371:05 send one more message. As you can tell, it is just scrolling.
371:11 Let's say 1 2 3. Okay. So, it is always going to scroll
371:17 to the very la very last message. And here I just realized the And here I just
371:24 realized this time is not correct. So let's try to fix it under the chat
371:30 container where we have the message created at date. I think code rabbit
371:35 told us this is not correct but I said yes it is correct. Looks like it isn't. So just go ahead get this suggestion
371:42 that we had from the code rabbit. Okay. So this is going to make it work correctly. This is my local time like it
371:50 is afternoon. I'll say ABC. The time is correct 12:00 p.m. Otherwise, let me
371:57 just do Ctrl Z. This was not really correct like this is ISO time. But here,
372:04 this is the local time. So, you will always see your local time
372:09 right here. Okay, so that's it. Let me just put a comment here as well. If
372:15 you're just reading the source code and not watching the tutorial, this is the scroll target that we created. So I
372:22 think that's the entire section. Everything is working other than realtime messages. So currently we can
372:29 send the message but it is not in real time. The other user needs to refresh every single time so that they can see
372:36 the latest message. But in the next section we are going to implement scikit io so that it is working in real time.
372:43 So let's open up the status bar create a new branch. Let's say message input.
372:54 And we're going to stage all of our changes. Let's say
373:00 send message functionality implemented.
373:08 Commit publish and let's create the pull request.
373:16 Okay. So let's wait for the reviews to check if we have any potential issues in our codebase. So here are the new
373:23 features that we have introduced in this section. You can pause the video and read it. Let's not waste any time. Here
373:30 is the sequence diagram as well as the file changes. Then let's scroll to the bottom to see some suggestions.
373:37 Um so here it says instead of using 5 megabytes, you can extend it for base
373:42 for 64 images. So it says you can go with 10 to 15 megabytes. If you wanted
373:49 to, you can do it. I'm going to skip that. So at least you know how to how to
373:54 do it, right? Under the express JSON, you would add the limit field. Then here
373:59 it says you could just return it if there is no file instead of doing it in this way. I think that's also fine. I'll
374:07 just scroll. I'll skip this, but you can add it definitely. Um here it again has
374:13 some suggestions. Not really a problem. Then it says instead of doing it in this
374:19 way, you can make this code a little bit more clean. I absolutely agree, but
374:25 let's not waste any time. I'm going to skip this at least since I am creating the tutorial. Um you're watching you can
374:33 like copy it and paste it. Make the code a little bit more clean if you really wanted to. Okay. So, let's merge this.
374:43 Then let's go here. Just try to switch to the master
374:50 and then get the latest changes.
374:55 Okay. So now our codebase is up to date. And by the way, you can click to this multiple times like nothing happens. The
375:03 point of this is to sync the changes, right? Okay. So you can take a look at the end
375:10 result. By the way, since we just merged it, it's going to redeploy it again and you can visit the application.
375:18 Um once this is done, you should be able to see the latest changes.
375:24 So currently it doesn't have the message input, but once this is done, you should
375:29 be able to see it. All right. So in the next section, we are going to make the messages work in real time and hopefully
375:35 complete this tutorial. So I'll see you there. So finally we can make our
375:41 application work in real time by introducing a scikit server and for this
375:47 we will use scikit.io. Just before we write any code let me walk you through it with some diagrams. So this is the
375:55 current state of our back end. We have a rest api with express that handles the
376:02 http requests right. So we can update our profile, send messages where we can
376:08 save them to our database and fetch them. But now we would like to make that work in real time by adding a scikit
376:16 server. Right? So we will keep everything as it is and on top of it we will introduce this new server. So it's
376:24 going to work like some uh features are going to work in real time. Let's say
376:30 the online users is one of those features and the real time messages.
376:38 Okay. Now let's see some examples right here how this is going to work in real
376:43 time. So let's say we have two different users and they want to communicate in real time and we have a scikit server
376:51 that is going to handle this. So this user wants to send a message saying
376:57 something like hey. But it is not as easy as just sending the message. We
377:03 need something in middle right the man in the middle that is going to handle it. So let's say uh this user will send
377:11 a message to the server like hi and this is going to take this message in real
377:18 time and send it to this user. So whatever the content is, it is not going
377:24 to be changed. It'll just be sent. And this user didn't request it, right? It
377:30 is just listening for any incoming messages. So this guy didn't need to refresh the page without requesting
377:37 anything. Okay? Now, this means we can listen for events. Let's say listen for
377:46 events in the front end.
377:54 And we can listen for events in the back end, right? In the server.
378:03 Okay. So, just keep this in mind. It is not like you can only listen for events
378:08 on the server or only in the front end. Nope. You can actually listen in both of
378:14 these places. And this is what we're going to be doing in this video. Now just to be professional here, I'd like
378:20 to give you some quick notes that you can pause the video and read it. Actually, this is what I'll be doing. So
378:27 what is psychio in the first place? It is a powerful real-time communication
378:33 library for web applications. It enables instant birectional communication
378:39 between web clients and servers and it allows data to be pushed to clients in
378:45 real time without need for the client to request it. Right? It's really
378:50 important. You don't really like you don't need to request it without you asking. Data is just coming in real time
378:58 since you just set up your codebase. Now why sitio? Please go ahead and read it.
379:04 But basically we would like to just focus on building features rather than thinking all these networking issues
379:12 behind the scenes. And here are some examples. We can build a real-time chat app, realtime dashboard, collaborative
379:19 tool or some games. Okay. Now there are two different
379:24 packages that we will be using. On the back end it is scikit.io and in the
379:30 front end it is scikit.io client. Okay, so let's first get started with the back
379:36 end. I will open up my terminal. Under the back end, I'll say mpm installs
379:42 scikit.io. And this is the version that I'll be using 4.8 8.1.
379:50 So it is going to install those packages. We can go under the source under the lib and set up our scikit
379:58 server. So say scikit.js. And first I'd like to import a couple of different
380:03 things. Let me please copy and paste them. So we'll get the server from
380:09 scikit.io. This is our scikit server. And we'll get the http. You don't need
380:14 to install this package. It is built into into the node. We will import express and our environment variables.
380:22 Now first I'll create an express app. And you might be asking why are we creating this again? because we already
380:30 have one here. Now that's correct but we are going to delete this in a couple of minutes and instead we will use this one
380:38 instead and you will see why. Um here let's say we would like to create a
380:43 server by using this method and we are going to pass our express app into it
380:49 and then let's try to create a socket server. So I'll say socket server and
380:55 we'll just say new server. Okay. So on top of this, we're going to put our HTTP
381:03 server, right? So let's put this server on top of it. Now the uh the convention
381:09 is to call this as IO. So you don't really say something like socket server. Okay? So you would just say IO. I don't
381:16 know like this is the convention that we use. So what we have seen here, what we
381:21 have done here is the exact same thing that I just explained. On top of our on
381:27 top of our express API, Express server, we just introduced a new socket server,
381:33 right? I hope that makes sense. Now we would like to configure this by passing
381:38 an object. We'll say handle the course errors. Let's say this will be
381:44 environment.client URL. And for the authentication, we'll
381:50 just say credentials. Why are we having an error? I think this
381:56 should be an object. Let me cut this part. Okay. So, we are going to pass this as
382:04 an origin and then we'll say credentials equal to true. So that from the client we send
382:11 cookies. Okay. So once again this is the same thing that we have done right here.
382:19 But this is for our scikit server. So we will be able to we will be able to
382:25 authenticate our scikit clients as well. And let's actually do it here. I'll say
382:31 apply apply authentication middleware to all scikit connections. And here is how
382:37 we can do it. We'll say io use just before you do anything else go ahead and
382:43 call this scikit oath middleware which is something that we are going to create
382:49 under the middleware folder. So we already have one for the http requests
382:56 right under the request we are going to put the user if user is authenticated.
383:01 Now we'll do the same thing but this time for socket. So I'll say scikit.
383:07 Middleware.js file and let's try to create this file step
383:14 by step together. First I'll get three different imports which is this package
383:20 the JWT user model as well as our environment variables. Let's say export
383:27 const socket o middleware. This will be an async method where we can get the
383:34 scikit as well as the next method. Now this scikit is basically the user
383:42 that is connected from the front end. Okay. So this is our scikit connection.
383:48 Let's save and try to import it and let's keep building this
383:54 um this method. So first I will have a try and catch block. Here we would like
384:00 to first extract the token from our HTTP
384:06 only cookie right let's say grab this from our cookies and here I'll just
384:13 paste this in this is how we can extract it we will go
384:18 under the socket under the handshake headers and cookie we are going to split
384:23 that I mean split that with these I don't know how to call this but we have
384:29 a semicolon and space we will find the JWT value and this is going to give us
384:35 the token and then we can check if token is valid or if token even existed or not
384:44 so if there is no token just say unauthorized no token provided but if we
384:50 have the token we would like to verify it right here I'll say verify the token
384:58 and this This is something that we have done in the past in this file, right? This is the exact same thing. And now
385:05 we'll say if there is like if it is not valid, we'll say invalid.
385:11 Now finally we can find the user in the database just by doing this same exact thing. We
385:19 are going to find the user by passing the user ID. Let's say find the user
385:25 from DB. If it is not found just throw an error but else we can attach this to
385:32 the socket connection. So I'll say socket dot user is equal is equal to
385:40 this user. I cannot talk for some reason and then we'll say socket dot user id is
385:47 equal to user. So I think I accidentally imported this use from react but this
385:55 should be user dot underscore id and let's convert this to be a string.
386:06 Then finally we can just call the next method. Okay. So here I'll put a console log
386:14 just saying socket authenticated for this user
386:19 and in the catch we can put a console log and handle the errors as we need.
386:27 Okay. So this is almost exact same thing that we have done right here but instead
386:32 of using the request we will use the socket connection right. So here I'll
386:38 say attach user info to scikit and we
386:44 are going to be using these in a couple of minutes. So this is the entire code that we have just written. Now let's go
386:52 under the scikit.js and build the rest of the code. Now we would like to store
386:58 the online users. Right? So I'll um I'll just create an object. I'll say user
387:06 socket map first. It'll be an empty object and this
387:13 is going to be in this format. So we will have the key as the user ID and
387:19 value as the socket ID and I can put a comment. This is for storing online
387:25 users. Okay. Now when a user connects we can listen listen to it by doing this.
387:33 We'll say io.on on connection. So when there is a connection we can call this
387:40 call back method which is going to get the socket.
387:45 So this is the connected user right. So we can say something like user
387:50 connected. Let's actually do a user connected.
387:58 And if you really wanted to you can put the user sorry socket dot user full
388:05 name. Now you are able to access to the user field because we have introduced
388:11 our middleware right. So under the socket now you can get the user. If you
388:17 didn't had this line this would be undefined. So when a user connects that means we
388:24 can update the online user list. Right? So first I'll get the user ID
388:31 say socket dot user id then we can update our online user list. I'll say
388:37 user socket map. Here is the key which is the user ID.
388:43 It's going to be equal to scikit do ID. So we said the key will be user ID and
388:51 value would be scikit ID. Okay. Now we just updated our list in the back end.
388:58 We need to send it to every single user in our application. So just think about
389:03 it. We have let's say five different users in our application, right? So
389:10 let's say we have all these. Let me put them here
389:18 and get the observer. Okay. So let's say we have
389:25 four different users in our application, right? And someone just signed up. That
389:30 means we have one more user that is just online. Um this server needs to send the
389:36 event to everyone to say, "Hey guys, this user is just logged in or he is
389:43 online now." Right? So all I'm trying to say is that we would like to send this event to everyone in our application.
389:51 And for this we will use a method called io.eit. So we'll say io emit and we
389:58 would like to pass an event name of the event. I can say get online users. You
390:05 can call this anything but this is the name that I'll be going with and I'll say io.it emit
390:13 is used to send events to all connected
390:20 clients. So this is the event name we would like to send our updated list
390:26 right. So we just updated the list. We would like to send it by doing this.
390:31 I'll say object keys. We will basically send the keys in this socket map which
390:38 are the user ids. So I'll say pass the user map.
390:45 Okay. So this will take all the keys and send it back to the client. Then we can
390:51 listen for the disconnections. So I will say socket.on.
390:56 This is how we can listen for an event as well. I'll say disconnect.
391:02 When someone disconnects, we can call this method just like this. I will copy it, paste
391:09 it. I'll say a user disconnected and we can put the full name. Then we would
391:14 like to update our list. So I will say delete from the user sit map just delete this
391:22 user ID because this user just disconnected. Then we would like to call
391:28 the same thing so that we can inform the client. We will just say hey everyone
391:35 just please notice here is the updated list someone just disconnected. So
391:40 that's the entire code to handle online and offline users. I know that this
391:46 might look a little bit weird if you're using it for the very first time, but as you do it more, I think this will look
391:53 pretty easy to understand. I can walk you through it once again. So here we
391:58 just try to create a server that is including our rest API as well as the
392:04 scikit server, right? So we can handle all the HTTP requests and the real time
392:10 events. We authenticated our socket as well, right? Our socket connections are
392:18 also authenticated. This is something that you wouldn't see in other tutorials, even in my tutorials. So,
392:24 this is something really important that I just introduced for the very first time in my tutorials. And then for the
392:32 online users, we are having an empty object. And this is how we called it.
392:38 It'll take the key and value pairs in this way. User ID to socket ID. And we
392:45 can listen for connections by doing this. IO.on connection. When someone
392:51 connects, we will take them as a socket. We can put a console log and update our
392:57 list. Now, we just updated the list only in the back end. We would like to let
393:03 everyone know that here is the new list. And this is how we can do it with io.mit
393:10 to send events to everyone at the same time. And then for the disk connections,
393:16 this is what we'll be doing. And from here on out, just keep that in mind. Whenever we listen for an event, we will
393:23 be using socket.on. Okay, both in the back end and in the client. So this is
393:29 just one exception. Instead ofon, we are using io.on on and listen for an event
393:36 because here we don't really have the socket so we had to use the IO once we
393:41 have the socket connection then we'll just use socket on and listen for any
393:47 any events right here you can add more events let's say scikit on this could be
393:53 anything you would just give an event name like whatever that is and then
393:58 handle your logic within the callback okay so I'll just put a comment with
394:05 socket.on you or let's say we listen for events.
394:11 Since we are in the back end, we are listening from the clients. But in the client, if we use scikit on that means
394:18 we are listening for events from the back end. Okay. Again, this should make
394:24 sense as we go through this course. All right. So at the very end we can say
394:29 export all these things which is the IO the app as well as the server.
394:38 Now we'll go under the server.js. We are going to delete this app and
394:44 let's say import this from scikit.js and instead of listening for this app we
394:51 will listen for the server. Okay. So I just import the server
394:56 from scikit.js. So we still have our express app where we are handling our API routes and on
395:04 top of this we are listening to server so that we can have the socket realtime
395:11 communication. All right. So that's the setup for now in the back end. We are
395:16 just handling the online users. Let's try to go in the front end. And let's by
395:22 the way run uh the back end. I'll just say mpm rundev.
395:27 Now let's go into the front end kill this app and we will we would like to say mpm install socket.ioclient
395:37 and let's give a specific version which is going to be the exact same thing the
395:43 4.8.1 version.
395:49 Okay. So go ahead, install it and run our front end as well.
395:56 Then let's try to kill everything. Go under the oath store and we will
396:03 create one function. So first I will create a state called
396:09 socket and this will be equal to null. And let me kill the AI so that it is not
396:15 really annoying. Okay, so we just created one state which
396:21 is socket and then I will have a method like connect socket. So let's say this
396:27 will be an arrow function and this is going to allow us to connect
396:33 to our socket server and we are going to be calling this whenever we sign up or
396:39 whenever we log in right. So here let's say something like first get the oath
396:45 user from the getter. So we need to get this
396:52 get as the second argument and by using it we will get the oath user. So first
396:58 I'll say if there is not an authenticated user we can just return out of this function. We don't want to
397:05 connect because user is not authenticated. And one more optimization we can say get the scikit connection.
397:14 I'll say get dots socket and I'll say if we are already connected just return
397:21 don't try to connect again and let's optional change this okay now we can
397:27 create the connection I'll say socket called the IO and we are going to be
397:33 importing it from our package and we are going to create a base URL so
397:40 here I'll say if we are in the development ment. This is our backend URL, but else just use the same domain.
397:50 Again, we have done this in the axios.js. I explained this in detail. Right here,
397:56 we're using the API, but in this case, we'll just use the default like only the
398:02 root. Okay. Now, let's call the IO method. We will paste the base URL as
398:09 the first option. And then we can say with credentials equal to true so that
398:16 we can send the cookies in the request here. I'll just give a little bit space
398:21 and give you a comment. So this ensures cookies are sent with the connection. We
398:27 got the socket. We can just say socket.connect
398:33 call the method and then we can update our state. So I'll just say set our
398:39 socket state with this socket connection. And since they're the same
398:44 thing, I can shorten this. All right. So we just connected. Now we would like to
398:50 listen for events that are going to be coming from the back end. And let's say
398:55 listen for online users event. And as I
399:00 said previously, if you want to listen for events, you would say socket.on on
399:06 and our event name was get online users
399:11 and then we are going to get the user ids then we can do something so once again
399:18 I'll open up the socket.js JS here is the event name that we are
399:23 sending from the server and we are sending the user ids. So just make sure
399:29 this name is matching with this one. Okay. So we're going to get the user ids
399:35 and we can set our online users state
399:41 with the user ids.
399:47 Now I think we don't have this state. Do we have it? No, we don't. So let's say online users. Initially, it's going to
399:54 be empty. And then we will update it right here. Okay. So that's the entire
400:00 method. We check if user is authenticated or not. If not, we'll just return. We are not going to do anything.
400:07 But if user is authenticated, we are going to connect to it. Call the connect method. Um set our state, the scikit
400:15 state, and listen for online users. Then we can create one more method called
400:22 disconnect. Say disconnect socket. This going to be
400:27 pretty easy, pretty basic. We'll just say get the socket
400:36 and call the disconnect method. Disconnect.
400:45 Okay. So we are getting the socket state and calling the disconnect method. And I
400:51 think I have a typo. Let's fix this. Then here I'd like to optimize this a
400:56 bit. I'll say if the scikit is connected only then try to
401:02 disconnect. So I'll say get the cit state and if this is connected
401:10 if this is equal to true only then try to disconnect.
401:16 Okay. Now whenever we log in we would like to call this method and when we log
401:21 out we're going to call this method. So here let's say under the login
401:27 once we set our state and show the success to host we can just say
401:34 get the like connect method connect and call this and we are going
401:42 to do the same thing when we sign up and when we check for the authentication
401:49 basically when you refresh the page you're going to call the method meth.
401:55 You're going to call this method and if you're authenticated, you would like to connect to the socket. And when you log
402:01 out here, you would like to say disconnect socket.
402:10 Okay, so that's it. Let's open up the terminal under the back end and see if we have any connections. So, we already
402:17 have some stuff. Let me just clear this up. Oops. What am I doing?
402:27 What the heck? What have I done? Let me kill this. Okay, so this is where we left. I don't know what happened. I'll
402:34 open up the terminal once again. So, it says a user connected, which is John Do.
402:40 Let's try to log out. It should say user disconnected, which is John Do again,
402:47 right? So, let's try to log in with a different account. I think I'll go with this one
402:54 atgmail.com. 1 2 3 4 5 6. I just signed in. Okay, it
403:01 says this user connected and we are getting the authenticated console log as
403:06 well. This is the user ID and it is coming from the socket o middleware.
403:13 Okay, so it is coming from right here. Now this means online users are working
403:18 as expected and we can update our UI uh immediately.
403:24 So let's go under the chat list and first handle this online state.
403:30 Currently we are just using the online class no matter what happens but we have
403:36 a to-do to fix it now. So I'll delete this comment and let's try to fix it. So
403:41 first we would like to import the online users from our state from oath store
403:48 right. So we got the online users and here we will add this class dynamically.
403:54 So I'm going to delete the online class. We will say we always want to have the
403:59 avatar but this part is going to be dynamic. So here I'll say online users
404:05 doincludes. If it includes this chat
404:13 id that means we can add the online class but else we will add the offline.
404:20 Okay. So that's it. We would like to do the exact same thing for the contact
404:26 list. Let me get this line. Paste this
404:31 in. Import the oath store. And here again we have the to-do. Let's
404:38 delete it. And I'm going to copy this entire line.
404:46 Okay. So instead of chat, we call this as contact. I'll just say contact. If
404:52 this ID is in the online users array, that means they are online.
404:59 And now let's try to see these users are offline, right? I will create another
405:05 window. Now let's try to put them side by side
405:16 like this maybe. Okay. From here I'd like to log in as
405:23 John. So I'll say John do atgmail.com.
405:28 1 2 3 4 5 6. As soon as I log in just notice here it should be green.
405:35 Okay. So that means it is working in real time. And if I try to log out now
405:41 this user is offline immediately and there is one more component that we would like to make it work in real time.
405:48 So this user is offline but here in the header we can see it says online. So
405:54 let's go ahead visit that and fix it which is going to be under the chat header component. So from the oath store
406:03 again I will get the online users and we can check if the selected user is online
406:09 or not. And here is how we can do it. We will say if selected user is in this
406:15 array that means that user is online. Now let's scroll to the bottom here.
406:20 Instead of having this class let's delete that and make this to be dynamic.
406:28 I'm going to wrap this with uh curly braces. Open up the back takes
406:35 and then here I'll say if this user is online add the online class
406:44 else add the offline class. Okay. So I'm going to copy the entire thing
406:50 and paste it. Let's see where that is. So I think I will update this state. Um
406:57 here I'm going to delete it. Let's say if is online have this text
407:06 else we'll just say offline. Okay let's save. Put them side by side.
407:12 Now it says offline. Let's try to log in pretty quickly at hgmail.com.
407:21 Now once I log in it should both update here and this part.
407:27 Okay, it is working in real time. Let's try to log out again. Everything is updating as
407:34 expected. So that's the online users feature. I hope it wasn't really confusing. Let me go ahead kill
407:41 everything and walk you through it once again. So first we set it up our
407:46 scikit.js file. And this is including our authentication middleware. So I have
407:53 explained this. I'm going to skip that. So, here is the important part for online users. We have an array or we
408:02 have an object where we store the users and this is storing the user ids. So,
408:08 here's here's the key. Here's the value. When someone connects, we are updating
408:13 the list and letting everyone know that this user is online, right? We just say,
408:21 "Hey everyone, here is the updated list. We just got a new user that is
408:26 connected." And then when someone disconnects, we delete it from the map.
408:31 And again, we just say, "Hey everyone, here is the updated list. Someone just became offline." And then under the oath
408:40 store, let's go here. We have a method called connect socket
408:47 where we basically connect our socket server, update our state and listen for
408:53 any incoming events for online users. And same for the disconnect method. Then
409:01 we are calling them whenever we log in. If we log out, we call the disconnect
409:07 in the signup. And then in the check out we are calling the connect method.
409:14 Okay. And we have an array for online users and we are checking this in the
409:19 let's say I don't know contact list. We get the state and depending on that
409:27 we update the class name or the text. Okay. So I hope that makes sense. It
409:32 could be a little bit confusing if you're using it for the very first time, but um other than this, that's the
409:39 entire logic. Let's go ahead commit our changes. I'll say create a new branch.
409:47 Let's say online users. In the next section, we are going to implement the real time messages and then hopefully
409:55 just uh complete the entire tutorial. So this is our new branch say online users
410:05 implemented
410:10 committed and publish that branch.
410:20 Let's create the pull request and then wait for the code review from code rabbit. So here are the new features
410:28 that we just introduced in this section and the files that we have updated as
410:33 well as the sequence diagram that you can take a look at. Now let's take a look at the code suggestions that we
410:41 have. Now here it says instead of using a map like a JavaScript object, you
410:47 could actually use the the map um like new map coming from JavaScript. I think
410:55 that's a pretty valid suggestion. We could do it. I'm going to skip this because it is a little bit more
411:01 advanced, but definitely feel free to pause the video and try to implement
411:06 this if you really wanted to. Again, it's a little bit more advanced. I'd like to skip that. Here it says, make
411:13 your code a little bit more safe by adding the conditionals. I'm going to
411:19 skip that. Same for this one. So these are just some suggestions just
411:26 to make our code not break easily. Okay, I'm going to skip all of them so that we
411:32 don't really waste any time. Let's say confirm the merge. Once it is done, we
411:37 can go back to the master branch and get the latest changes by clicking
411:44 to this button. Okay, so now our codebase is up to date.
411:50 Here you can see we got all these files that we just created
411:56 and this should trigger a new deploy under the deployments and then you can
412:02 check the live app um if it includes the online offline users and it is actually
412:09 like it should work absolutely at the end of the next section we are going to
412:15 test it out completely. So we're going to test out the online users in the deployment as well as the real-time
412:21 messages which is something that we're going to build in the next section. So I'll see you there. All right. So let's
412:29 implement real time messages. It is actually easier than what you think. First we will visit the scikit.js file.
412:37 And here let me go ahead and create a function. So let's create it. It is just
412:43 one line. and and I will explain what that does. So let's say export function
412:49 get receiver socket ID and we are going
412:54 to pass the user ID as an argument and it is going to return us from the user
413:02 socket map. We will pass the user ID and it'll give
413:07 us the scikit ID. Okay, so we're going to pass the user ID into this method and
413:12 it is going to give us the receiver socket ID and we are going to be using
413:18 this method. So let me put this as a comment. We will use this function to
413:23 check if user is online or not. Okay, so we are having this object to store the
413:30 online users and we are using this method to check if the user is online or
413:36 not. And let's see uh like how can we call this. First we will visit the
413:41 messagecontroller.js file. And here we have a to-do under the
413:47 send message method. Right. So here we have a to-do where we just said we are
413:52 going to make it work in real time if user is online. So first let's say give
413:59 us the receiver socket id and we can get this by calling our
414:06 method. So let's say get receiver psych ID where we will pass the receiver ID
414:12 right. So this is the user ID that we're going to pass and it's going to give us the scikit ID and we can say if receiver
414:21 id if this is existed that means user is online and we can send an event. So I
414:28 will say ioit new message
414:33 now we just said if if we use io.mit this is going to send it to everyone.
414:40 That's right. So we would like to send it only to this user and we can say io2
414:50 and then emit and the two is going to take an argument which is the receiver
414:56 socket id. So now we are sending this event to only this this user right now.
415:02 Now we can call this anything really like literally anything but it should be something that makes sense when we read
415:10 up when we read our code. So new message this is what I'll be using. And then
415:15 let's say we would like to send the new message. So this is the event name and
415:20 this is the actual thing that we are sending with the event. So that's the entire thing that we need to do. Just
415:27 check if user is online or not. If it is online, send the message. Now we will go
415:33 into the let's say use chat store hook
415:39 or the store I should say. Let's shrink everything and we will create two
415:44 different methods. So the first one is going to where we listen for any incoming messages. So I will say
415:52 subscribe to messages and also subscribe to the
415:57 channel right here. Let's go ahead create this. So this is going to listen
416:02 for any incoming messages right as the name suggests we will subscribe to
416:07 message events. So first I will get the selected user and if sound is enabled or
416:14 not. You're going to see why. First let's say if there is no selected users
416:21 just don't do anything right just return out of this method. If there is no selected conversation
416:28 there is no need to listening for events but if a chat is selected then we can
416:34 listen for messages so that we can update the state immediately.
416:40 Okay. So here I will say give us the scikit connection and we can grab this
416:47 from the use oath store import that and just say get state and I think we don't
416:54 need to call this method just put the name and say get state call this and
417:01 then at the very end grab the socket state. So this is our socket connection
417:07 and we're going to be using it so that we can listen for events that are new messages right we are going
417:15 to listen for this event and server is going to send us a message so we can
417:22 call this function and do something inside so first I will get all my current messages in this chat so I'll
417:29 say const let's say current messages
417:35 And we can say get dot messages.
417:41 Basically we are getting our state. Okay. So these are all of our messages.
417:47 Then we are going to update the state. So we'll say keep all the current
417:54 messages and on top of it at the very end add the new message.
418:01 Okay. So that's the entire thing. Now there is one more thing I'll just say if
418:07 sound is enabled we can basically play a notification sound. So here I'll say
418:14 notification sound play and as always we would like to have this optimization
418:20 where we would like to reset to the start. Um let's import the notification
418:25 sound at the very top of this file. Okay. So it is this sound that we have.
418:37 Okay. So we would like to play this if sound is enabled.
418:42 Okay. Now let's save. Um we'll create the unsubscribe method as well. It is
418:48 pretty basic and easy. I'll just paste this in. Unsubscribe
418:53 from messages. We're going to get the scikit instance and we would like to
418:59 just unsubscribe, right? So we'll say scikit.off the new message. Okay. Now we would like
419:06 to call this under the chat container component. Let's scroll to the top.
419:13 Maybe shrink all of these. And here from our chat store, we will import the
419:20 subscribe to messages method as well as unsubscribe from messages. First, let's
419:26 save this. And I just realized this should be messages. Okay, so I just had a typo. Let me fix that. Then we would
419:34 like to go ahead create one more use effect. This is the very last one.
419:43 Let's initialize it. here we would like to so I think we don't need to even create another one so within this where
419:52 we fetch the messages right after this I'll say subscribe to messages right so
419:59 this is going to listen for any incoming uh message and then we can also say for
420:05 the performance reasons we can have the cleanup I'll say return
420:14 unsubscribe subscribe from messages and let's try to pass these methods.
420:23 Okay. So I think that's the entire entire configuration that we need to do.
420:28 First we are getting all the messages whenever we visit the chat container
420:33 right we fetch them and in the background we are listening for the new messages and let's try to actually see
420:39 it in action. I will put them side by side.
420:47 And I will log in as a John. Okay. So as this account
420:58 okay this user is online. Let's send a message here. I'll say hey.
421:05 Okay. As you can tell we are able to see it immediately in real time.
421:12 Yep. Let's say 1 2 3. Now this is getting like uh 1 second later. It is
421:18 because we are using optimistic updates right here. I'll say hey another
421:24 message. So notice how this will see it immediately and once it is done like
421:31 once it is saved to the database we will see it here as well. Okay. Now, I think I forgot to show you
421:38 this feature, but basically when we type in, we should be able to hear the
421:45 keyboard sound. So, first, let me turn off my keyboard sound. Now, I'll type
421:52 something in. So, I don't know if you can hear it. Let's make this desktop sound a little
421:59 bit more.
422:05 So this sound is coming from the actual website right these are the sounds that
422:10 we are playing from the public folder. Now let's say some more messages
422:18 send it and we should be able to hear the notification sound but for some reason
422:25 we cannot. Let's do it from here.
422:30 Okay. So I don't know why but this is not really working as expected.
422:38 So for some reason we cannot play it. Let's open up the terminal.
422:44 So I just paused the video and try to find the solution. Basically here we'll
422:50 go ahead under DVS code. Instead of initializing it here I am going to cut
422:55 this scroll to the bottom and create it right here. Okay. So, under the if
423:01 check, we will get the sound and play it. Now, let's test this out.
423:10 So, sound is enabled for both of these accounts. Let's say, hey,
423:16 we can hear it as you can tell. Let's send it from here
423:22 again. It's going to play that. Okay. So, I believe that's the entire thing. This is how easy it is to implement
423:28 that. First you would set it up on your back end. First we created a method so
423:34 that we can check if user is online or not. If user is online we are going to
423:40 send a message whenever we call this method. Right? And in the front end we
423:46 are going to subscribe to these events and we are going to unsubscribe once we
423:52 let's say once we get rid of this component. So under the cleanup method
423:58 now there is one optimization that I'd like to add. So here above the current
424:04 messages I will get a variable and let me paste this in. So this is what we
424:09 call if message is sent from the selected user. Okay. So this is how we
424:15 can check that if new message dot sender ID is equal to selected user ID that
424:21 means this message is sent from that user. And I will say if message is not
424:30 sent from this user, we can return and we don't really want to do anything. Now
424:35 you might be asking what this code does, right? So first let me comment this and
424:41 show you the problem. Then you're going to see why we need it in the first place. So I'm going to select the Jane
424:48 here. Okay. And I will get a message from John. So let's say John sends us a
424:55 message. Let's go ahead. We log in as John and send a message like hey I am
425:02 John. Now looks like Jane sends us this message but it is not correct. Jane is
425:10 offline right? If you take a look at the John conversation you're going to see
425:15 the message and here now it is not there. But if you select it and if you
425:21 get the message in real time looks like Jane sent you the message. So for that
425:27 reason we will say if this message so if message is not sent from the
425:34 selected user just don't update the UI right return immediately.
425:41 Now if you save the code and take a look at it I'm going to select and do the same thing. I'll say hey I am John sent
425:51 the message. Now we don't really see it because this message is coming from
425:56 John. Okay. So I hope you can see the uh
426:02 optimization. This is really really important. Okay. So just keep this in
426:07 mind. Now I think we just completed the entire tutorial. I will see if we have
426:12 any to-dos. Looks like we don't. and we can commit all of our changes. So I will go under
426:19 the branches. Let's say real time messages
426:29 create the branch and stage all of our changes.
426:41 And here is my commit message. Let's publish that
426:48 and then from the source code as always we will just create the pull request.
426:59 So as always we can wait for the suggestions from code but I think in
427:04 this section I'll just go ahead and merge the pull request. Since we are at the very end, let's not waste any time.
427:13 Since everything is working, I'll just skip this step. Now, let's go back to the master
427:21 and get the latest changes.
427:28 Now, this is going to trigger a new deploy. Let's wait for this to be
427:33 completed and then we can check it out if everything is working. in production
427:39 as well. And by the way, let's see if we have any environment variables
427:45 that we didn't add already. Um, under here, let's say environment
427:51 variables, we have arcad key.
427:56 Okay. So, I think we have included everything. So, we are not missing any environment variables under the Savala
428:03 dashboard. Okay. So let's wait for the deployment to be completed. All right. So looks
428:10 like the deployment done successfully. Let's go ahead and test it out in production. So I will copy the URL
428:18 and let's paste it here
428:24 and let's try to log in with this account.
428:31 And by the way, under the contacts, we can see here are all the users, right?
428:36 We have John, but we just don't have a message with them, right? It's not our
428:41 chat partner. So, let's try to log in with this account.
428:48 Come. Let's say 1 2 3 4 5 6.
428:53 Okay, this user is online. As you can tell, Jane is online. Now, we'll just send a message. Let's
428:60 say hey. All right. So, we can get it in real
429:05 time. Now, since this is not local host, there is a little bit more delay, but
429:10 still it is working in real time, right?
429:16 Okay. So, let's try to open up the notification sound and say, "Hey,
429:25 again, we cannot hear it. Let's maybe refresh.
429:30 Jane is online. This user is online. Let's send again.
429:37 Okay, now we can hear it. Notification sounds are working. Now I'll try to log
429:42 out as Jane. And notice here it should immediately update.
429:49 Okay, now Jane is offline. So that means our application is also working in
429:54 deployment as expected. So with this I think we completed the entire tutorial.
429:59 I hope you enjoyed it. We went from back end to the front end to connecting both
430:04 of them and deploying the application. So hopefully I'll see you in the next